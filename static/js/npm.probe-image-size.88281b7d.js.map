{"version":3,"file":"js/npm.probe-image-size.88281b7d.js","mappings":"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","sources":["webpack://wellcast/./node_modules/probe-image-size/lib/common.js","webpack://wellcast/./node_modules/probe-image-size/lib/exif_utils.js","webpack://wellcast/./node_modules/probe-image-size/lib/miaf_utils.js","webpack://wellcast/./node_modules/probe-image-size/lib/parse_sync/avif.js","webpack://wellcast/./node_modules/probe-image-size/lib/parse_sync/bmp.js","webpack://wellcast/./node_modules/probe-image-size/lib/parse_sync/gif.js","webpack://wellcast/./node_modules/probe-image-size/lib/parse_sync/ico.js","webpack://wellcast/./node_modules/probe-image-size/lib/parse_sync/jpeg.js","webpack://wellcast/./node_modules/probe-image-size/lib/parse_sync/png.js","webpack://wellcast/./node_modules/probe-image-size/lib/parse_sync/psd.js","webpack://wellcast/./node_modules/probe-image-size/lib/parse_sync/svg.js","webpack://wellcast/./node_modules/probe-image-size/lib/parse_sync/tiff.js","webpack://wellcast/./node_modules/probe-image-size/lib/parse_sync/webp.js","webpack://wellcast/./node_modules/probe-image-size/lib/parsers_sync.js","webpack://wellcast/./node_modules/probe-image-size/sync.js"],"sourcesContent":["'use strict';\n\n\nvar Transform    = require('stream').Transform;\nvar streamParser = require('stream-parser');\n\n\nfunction ParserStream() {\n  Transform.call(this, { readableObjectMode: true });\n}\n\n// Inherit from Transform\nParserStream.prototype = Object.create(Transform.prototype);\nParserStream.prototype.constructor = ParserStream;\n\nstreamParser(ParserStream.prototype);\n\n\nexports.ParserStream = ParserStream;\n\n\nexports.sliceEq = function (src, start, dest) {\n  for (var i = start, j = 0; j < dest.length;) {\n    if (src[i++] !== dest[j++]) return false;\n  }\n  return true;\n};\n\nexports.str2arr = function (str, format) {\n  var arr = [], i = 0;\n\n  if (format && format === 'hex') {\n    while (i < str.length) {\n      arr.push(parseInt(str.slice(i, i + 2), 16));\n      i += 2;\n    }\n  } else {\n    for (; i < str.length; i++) {\n      /* eslint-disable no-bitwise */\n      arr.push(str.charCodeAt(i) & 0xFF);\n    }\n  }\n\n  return arr;\n};\n\nexports.readUInt16LE = function (data, offset) {\n  return data[offset] | (data[offset + 1] << 8);\n};\n\nexports.readUInt16BE = function (data, offset) {\n  return data[offset + 1] | (data[offset] << 8);\n};\n\nexports.readUInt32LE = function (data, offset) {\n  return data[offset] |\n    (data[offset + 1] << 8) |\n    (data[offset + 2] << 16) |\n    (data[offset + 3] * 0x1000000);\n};\n\nexports.readUInt32BE = function (data, offset) {\n  return data[offset + 3] |\n    (data[offset + 2] << 8) |\n    (data[offset + 1] << 16) |\n    (data[offset] * 0x1000000);\n};\n\n\nfunction ProbeError(message, code, statusCode) {\n  Error.call(this);\n  Error.captureStackTrace(this, this.constructor);\n\n  this.name = this.constructor.name;\n\n  this.message = message;\n  if (code) this.code = code;\n  if (statusCode) this.statusCode = statusCode;\n}\n\n// Inherit from Error\nProbeError.prototype = Object.create(Error.prototype);\nProbeError.prototype.constructor = ProbeError;\n\n\nexports.ProbeError = ProbeError;\n","\n/* eslint-disable no-bitwise */\n/* eslint-disable consistent-return */\n\n'use strict';\n\n//////////////////////////////////////////////////////////////////////////\n// Helpers\n//\nfunction error(message, code) {\n  var err = new Error(message);\n  err.code = code;\n  return err;\n}\n\n\nfunction utf8_decode(str) {\n  try {\n    return decodeURIComponent(escape(str));\n  } catch (_) {\n    return str;\n  }\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n// Exif parser\n//\n// Input:\n//  - jpeg_bin:   Uint8Array - jpeg file\n//  - exif_start: Number     - start of TIFF header (after Exif\\0\\0)\n//  - exif_end:   Number     - end of Exif segment\n//  - on_entry:   Number     - callback\n//\nfunction ExifParser(jpeg_bin, exif_start, exif_end) {\n  // Uint8Array, exif without signature (which isn't included in offsets)\n  this.input      = jpeg_bin.subarray(exif_start, exif_end);\n\n  // offset correction for `on_entry` callback\n  this.start      = exif_start;\n\n  // Check TIFF header (includes byte alignment and first IFD offset)\n  var sig = String.fromCharCode.apply(null, this.input.subarray(0, 4));\n\n  if (sig !== 'II\\x2A\\0' && sig !== 'MM\\0\\x2A') {\n    throw error('invalid TIFF signature', 'EBADDATA');\n  }\n\n  // true if motorola (big endian) byte alignment, false if intel\n  this.big_endian = sig[0] === 'M';\n}\n\n\nExifParser.prototype.each = function (on_entry) {\n  // allow premature exit\n  this.aborted = false;\n\n  var offset = this.read_uint32(4);\n\n  this.ifds_to_read = [ {\n    id:     0,\n    offset: offset\n  } ];\n\n  while (this.ifds_to_read.length > 0 && !this.aborted) {\n    var i = this.ifds_to_read.shift();\n    if (!i.offset) continue;\n    this.scan_ifd(i.id, i.offset, on_entry);\n  }\n};\n\n\nExifParser.prototype.read_uint16 = function (offset) {\n  var d = this.input;\n  if (offset + 2 > d.length) throw error('unexpected EOF', 'EBADDATA');\n\n  return this.big_endian ?\n    d[offset] * 0x100 + d[offset + 1] :\n    d[offset] + d[offset + 1] * 0x100;\n};\n\n\nExifParser.prototype.read_uint32 = function (offset) {\n  var d = this.input;\n  if (offset + 4 > d.length) throw error('unexpected EOF', 'EBADDATA');\n\n  return this.big_endian ?\n    d[offset] * 0x1000000 + d[offset + 1] * 0x10000 + d[offset + 2] * 0x100 + d[offset + 3] :\n    d[offset] + d[offset + 1] * 0x100 + d[offset + 2] * 0x10000 + d[offset + 3] * 0x1000000;\n};\n\n\nExifParser.prototype.is_subifd_link = function (ifd, tag) {\n  return (ifd === 0 && tag === 0x8769) || // SubIFD\n         (ifd === 0 && tag === 0x8825) || // GPS Info\n         (ifd === 0x8769 && tag === 0xA005); // Interop IFD\n};\n\n\n// Returns byte length of a single component of a given format\n//\nExifParser.prototype.exif_format_length = function (format) {\n  switch (format) {\n    case 1: // byte\n    case 2: // ascii\n    case 6: // sbyte\n    case 7: // undefined\n      return 1;\n\n    case 3: // short\n    case 8: // sshort\n      return 2;\n\n    case 4:  // long\n    case 9:  // slong\n    case 11: // float\n      return 4;\n\n    case 5:  // rational\n    case 10: // srational\n    case 12: // double\n      return 8;\n\n    default:\n      // unknown type\n      return 0;\n  }\n};\n\n\n// Reads Exif data\n//\nExifParser.prototype.exif_format_read = function (format, offset) {\n  var v;\n\n  switch (format) {\n    case 1: // byte\n    case 2: // ascii\n      v = this.input[offset];\n      return v;\n\n    case 6: // sbyte\n      v = this.input[offset];\n      return v | (v & 0x80) * 0x1fffffe;\n\n    case 3: // short\n      v = this.read_uint16(offset);\n      return v;\n\n    case 8: // sshort\n      v = this.read_uint16(offset);\n      return v | (v & 0x8000) * 0x1fffe;\n\n    case 4: // long\n      v = this.read_uint32(offset);\n      return v;\n\n    case 9: // slong\n      v = this.read_uint32(offset);\n      return v | 0;\n\n    case 5:  // rational\n    case 10: // srational\n    case 11: // float\n    case 12: // double\n      return null; // not implemented\n\n    case 7: // undefined\n      return null; // blob\n\n    default:\n      // unknown type\n      return null;\n  }\n};\n\n\nExifParser.prototype.scan_ifd = function (ifd_no, offset, on_entry) {\n  var entry_count = this.read_uint16(offset);\n\n  offset += 2;\n\n  for (var i = 0; i < entry_count; i++) {\n    var tag    = this.read_uint16(offset);\n    var format = this.read_uint16(offset + 2);\n    var count  = this.read_uint32(offset + 4);\n\n    var comp_length    = this.exif_format_length(format);\n    var data_length    = count * comp_length;\n    var data_offset    = data_length <= 4 ? offset + 8 : this.read_uint32(offset + 8);\n    var is_subifd_link = false;\n\n    if (data_offset + data_length > this.input.length) {\n      throw error('unexpected EOF', 'EBADDATA');\n    }\n\n    var value = [];\n    var comp_offset = data_offset;\n\n    for (var j = 0; j < count; j++, comp_offset += comp_length) {\n      var item = this.exif_format_read(format, comp_offset);\n      if (item === null) {\n        value = null;\n        break;\n      }\n      value.push(item);\n    }\n\n    if (Array.isArray(value) && format === 2) {\n      value = utf8_decode(String.fromCharCode.apply(null, value));\n      if (value && value[value.length - 1] === '\\0') value = value.slice(0, -1);\n    }\n\n    if (this.is_subifd_link(ifd_no, tag)) {\n      if (Array.isArray(value) && Number.isInteger(value[0]) && value[0] > 0) {\n        this.ifds_to_read.push({\n          id:     tag,\n          offset: value[0]\n        });\n        is_subifd_link = true;\n      }\n    }\n\n    var entry = {\n      is_big_endian:  this.big_endian,\n      ifd:            ifd_no,\n      tag:            tag,\n      format:         format,\n      count:          count,\n      entry_offset:   offset + this.start,\n      data_length:    data_length,\n      data_offset:    data_offset + this.start,\n      value:          value,\n      is_subifd_link: is_subifd_link\n    };\n\n    if (on_entry(entry) === false) {\n      this.aborted = true;\n      return;\n    }\n\n    offset += 12;\n  }\n\n  if (ifd_no === 0) {\n    this.ifds_to_read.push({\n      id:     1,\n      offset: this.read_uint32(offset)\n    });\n  }\n};\n\n\nmodule.exports.ExifParser = ExifParser;\n\n// returns orientation stored in Exif (1-8), 0 if none was found, -1 if error\nmodule.exports.get_orientation = function (data) {\n  var orientation = 0;\n  try {\n    new ExifParser(data, 0, data.length).each(function (entry) {\n      if (entry.ifd === 0 && entry.tag === 0x112 && Array.isArray(entry.value)) {\n        orientation = entry.value[0];\n        return false;\n      }\n    });\n    return orientation;\n  } catch (err) {\n    return -1;\n  }\n};\n","// Utils used to parse miaf-based files (avif/heic/heif)\n//\n// ISO media file spec:\n// https://web.archive.org/web/20180219054429/http://l.web.umkc.edu/lizhu/teaching/2016sp.video-communication/ref/mp4.pdf\n//\n// ISO image file format spec:\n// https://standards.iso.org/ittf/PubliclyAvailableStandards/c066067_ISO_IEC_23008-12_2017.zip\n//\n\n'use strict';\n\n/* eslint-disable consistent-return */\n/* eslint-disable no-bitwise */\n\nvar readUInt16BE = require('./common').readUInt16BE;\nvar readUInt32BE = require('./common').readUInt32BE;\n\n/*\n * interface Box {\n *   size:       uint32;   // if size == 0, box lasts until EOF\n *   boxtype:    char[4];\n *   largesize?: uint64;   // only if size == 1\n *   usertype?:  char[16]; // only if boxtype == 'uuid'\n * }\n */\nfunction unbox(data, offset) {\n  if (data.length < 4 + offset) return null;\n\n  var size = readUInt32BE(data, offset);\n\n  // size includes first 4 bytes (length)\n  if (data.length < size + offset || size < 8) return null;\n\n  // if size === 1, real size is following uint64 (only for big boxes, not needed)\n  // if size === 0, real size is until the end of the file (only for big boxes, not needed)\n\n  return {\n    boxtype: String.fromCharCode.apply(null, data.slice(offset + 4, offset + 8)),\n    data:    data.slice(offset + 8, offset + size),\n    end:     offset + size\n  };\n}\n\n\nmodule.exports.unbox = unbox;\n\n\n// parses `meta` -> `iprp` -> `ipco` box, returns:\n// {\n//   sizes: [ { width, height } ],\n//   transforms: [ { type, value } ]\n// }\nfunction scan_ipco(data, sandbox) {\n  var offset = 0;\n\n  for (;;) {\n    var box = unbox(data, offset);\n    if (!box) break;\n\n    switch (box.boxtype) {\n      case 'ispe':\n        sandbox.sizes.push({\n          width:  readUInt32BE(box.data, 4),\n          height: readUInt32BE(box.data, 8)\n        });\n        break;\n\n      case 'irot':\n        sandbox.transforms.push({\n          type: 'irot',\n          value: box.data[0] & 3\n        });\n        break;\n\n      case 'imir':\n        sandbox.transforms.push({\n          type: 'imir',\n          value: box.data[0] & 1\n        });\n        break;\n    }\n\n    offset = box.end;\n  }\n}\n\n\nfunction readUIntBE(data, offset, size) {\n  var result = 0;\n\n  for (var i = 0; i < size; i++) {\n    result = result * 256 + (data[offset + i] || 0);\n  }\n\n  return result;\n}\n\n\n// parses `meta` -> `iloc` box\nfunction scan_iloc(data, sandbox) {\n  var offset_size = (data[4] >> 4) & 0xF;\n  var length_size = data[4] & 0xF;\n  var base_offset_size = (data[5] >> 4) & 0xF;\n  var item_count = readUInt16BE(data, 6);\n  var offset = 8;\n\n  for (var i = 0; i < item_count; i++) {\n    var item_ID = readUInt16BE(data, offset);\n    offset += 2;\n\n    var data_reference_index = readUInt16BE(data, offset);\n    offset += 2;\n\n    var base_offset = readUIntBE(data, offset, base_offset_size);\n    offset += base_offset_size;\n\n    var extent_count = readUInt16BE(data, offset);\n    offset += 2;\n\n    if (data_reference_index === 0 && extent_count === 1) {\n      var first_extent_offset = readUIntBE(data, offset, offset_size);\n      var first_extent_length = readUIntBE(data, offset + offset_size, length_size);\n      sandbox.item_loc[item_ID] = { length: first_extent_length, offset: first_extent_offset + base_offset };\n    }\n\n    offset += extent_count * (offset_size + length_size);\n  }\n}\n\n\n// parses `meta` -> `iinf` box\nfunction scan_iinf(data, sandbox) {\n  var item_count = readUInt16BE(data, 4);\n  var offset = 6;\n\n  for (var i = 0; i < item_count; i++) {\n    var box = unbox(data, offset);\n    if (!box) break;\n    if (box.boxtype === 'infe') {\n      var item_id = readUInt16BE(box.data, 4);\n      var item_name = '';\n\n      for (var pos = 8; pos < box.data.length && box.data[pos]; pos++) {\n        item_name += String.fromCharCode(box.data[pos]);\n      }\n\n      sandbox.item_inf[item_name] = item_id;\n    }\n    offset = box.end;\n  }\n}\n\n\n// parses `meta` -> `iprp` box\nfunction scan_iprp(data, sandbox) {\n  var offset = 0;\n\n  for (;;) {\n    var box = unbox(data, offset);\n    if (!box) break;\n    if (box.boxtype === 'ipco') scan_ipco(box.data, sandbox);\n    offset = box.end;\n  }\n}\n\n\n// parses `meta` box\nfunction scan_meta(data, sandbox) {\n  var offset = 4; // version + flags\n\n  for (;;) {\n    var box = unbox(data, offset);\n    if (!box) break;\n    if (box.boxtype === 'iprp') scan_iprp(box.data, sandbox);\n    if (box.boxtype === 'iloc') scan_iloc(box.data, sandbox);\n    if (box.boxtype === 'iinf') scan_iinf(box.data, sandbox);\n    offset = box.end;\n  }\n}\n\n\n// get image with largest single dimension as base\nfunction getMaxSize(sizes) {\n  var maxWidthSize = sizes.reduce(function (a, b) {\n    return a.width > b.width || (a.width === b.width && a.height > b.height) ? a : b;\n  });\n\n  var maxHeightSize = sizes.reduce(function (a, b) {\n    return a.height > b.height || (a.height === b.height && a.width > b.width) ? a : b;\n  });\n\n  var maxSize;\n\n  if (maxWidthSize.width > maxHeightSize.height ||\n      (maxWidthSize.width === maxHeightSize.height && maxWidthSize.height > maxHeightSize.width)) {\n    maxSize = maxWidthSize;\n  } else {\n    maxSize = maxHeightSize;\n  }\n\n  return maxSize;\n}\n\n\nmodule.exports.readSizeFromMeta = function (data) {\n  var sandbox = {\n    sizes: [],\n    transforms: [],\n    item_inf: {},\n    item_loc: {}\n  };\n\n  scan_meta(data, sandbox);\n\n  if (!sandbox.sizes.length) return;\n\n  var maxSize = getMaxSize(sandbox.sizes);\n\n  var orientation = 1;\n\n  // convert imir/irot to exif orientation\n  sandbox.transforms.forEach(function (transform) {\n    var rotate_ccw  = { 1: 6, 2: 5, 3: 8, 4: 7, 5: 4, 6: 3, 7: 2, 8: 1 };\n    var mirror_vert = { 1: 4, 2: 3, 3: 2, 4: 1, 5: 6, 6: 5, 7: 8, 8: 7 };\n\n    if (transform.type === 'imir') {\n      if (transform.value === 0) {\n        // vertical flip\n        orientation = mirror_vert[orientation];\n      } else {\n        // horizontal flip = vertical flip + 180 deg rotation\n        orientation = mirror_vert[orientation];\n        orientation = rotate_ccw[orientation];\n        orientation = rotate_ccw[orientation];\n      }\n    }\n\n    if (transform.type === 'irot') {\n      // counter-clockwise rotation 90 deg 0-3 times\n      for (var i = 0; i < transform.value; i++) {\n        orientation = rotate_ccw[orientation];\n      }\n    }\n  });\n\n  var exif_location = null;\n\n  if (sandbox.item_inf.Exif) {\n    exif_location = sandbox.item_loc[sandbox.item_inf.Exif];\n  }\n\n  return {\n    width: maxSize.width,\n    height: maxSize.height,\n    orientation: sandbox.transforms.length ? orientation : null,\n    variants: sandbox.sizes,\n    exif_location: exif_location\n  };\n};\n\n\nmodule.exports.getMimeType = function (data) {\n  var brand = String.fromCharCode.apply(null, data.slice(0, 4));\n  var compat = {};\n\n  compat[brand] = true;\n\n  for (var i = 8; i < data.length; i += 4) {\n    compat[String.fromCharCode.apply(null, data.slice(i, i + 4))] = true;\n  }\n\n  // heic and avif are superset of miaf, so they should all list mif1 as compatible\n  if (!compat.mif1 && !compat.msf1 && !compat.miaf) return;\n\n  if (brand === 'avif' || brand === 'avis' || brand === 'avio') {\n    // `.avifs` and `image/avif-sequence` are removed from spec, all files have single type\n    return { type: 'avif', mime: 'image/avif' };\n  }\n\n  // https://nokiatech.github.io/heif/technical.html\n  if (brand === 'heic' || brand === 'heix') {\n    return { type: 'heic', mime: 'image/heic' };\n  }\n\n  if (brand === 'hevc' || brand === 'hevx') {\n    return { type: 'heic', mime: 'image/heic-sequence' };\n  }\n\n  if (compat.avif || compat.avis) {\n    return { type: 'avif', mime: 'image/avif' };\n  }\n\n  if (compat.heic || compat.heix || compat.hevc || compat.hevx || compat.heis) {\n    if (compat.msf1) {\n      return { type: 'heif', mime: 'image/heif-sequence' };\n    }\n    return { type: 'heif', mime: 'image/heif' };\n  }\n\n  return { type: 'avif', mime: 'image/avif' };\n};\n","// Utils used to parse miaf-based files (avif/heic/heif)\n//\n//  - image collections are not supported (only last size is reported)\n//  - images with metadata encoded after image data are not supported\n//  - images without any `ispe` box are not supported\n//\n\n/* eslint-disable consistent-return */\n\n'use strict';\n\n\nvar str2arr      = require('../common').str2arr;\nvar sliceEq      = require('../common').sliceEq;\nvar readUInt32BE = require('../common').readUInt32BE;\nvar miaf         = require('../miaf_utils');\nvar exif         = require('../exif_utils');\n\nvar SIG_FTYP = str2arr('ftyp');\n\n\nmodule.exports = function (data) {\n  // ISO media file (avif format) starts with ftyp box:\n  // 0000 0020 6674 7970 6176 6966\n  //  (length)  f t  y p  a v  i f\n  //\n  if (!sliceEq(data, 4, SIG_FTYP)) return;\n\n  var firstBox = miaf.unbox(data, 0);\n  if (!firstBox) return;\n\n  var fileType = miaf.getMimeType(firstBox.data);\n  if (!fileType) return;\n\n  var meta, offset = firstBox.end;\n\n  for (;;) {\n    var box = miaf.unbox(data, offset);\n    if (!box) break;\n    offset = box.end;\n\n    // mdat block SHOULD be last (but not strictly required),\n    // so it's unlikely that metadata is after it\n    if (box.boxtype === 'mdat') return;\n    if (box.boxtype === 'meta') {\n      meta = box.data;\n      break;\n    }\n  }\n\n  if (!meta) return;\n\n  var imgSize = miaf.readSizeFromMeta(meta);\n\n  if (!imgSize) return;\n\n  var result = {\n    width:    imgSize.width,\n    height:   imgSize.height,\n    type:     fileType.type,\n    mime:     fileType.mime,\n    wUnits:   'px',\n    hUnits:   'px'\n  };\n\n  if (imgSize.variants.length > 1) {\n    result.variants = imgSize.variants;\n  }\n\n  if (imgSize.orientation) {\n    result.orientation = imgSize.orientation;\n  }\n\n  if (imgSize.exif_location &&\n      imgSize.exif_location.offset + imgSize.exif_location.length <= data.length) {\n\n    var sig_offset = readUInt32BE(data, imgSize.exif_location.offset);\n    var exif_data = data.slice(\n      imgSize.exif_location.offset + sig_offset + 4,\n      imgSize.exif_location.offset + imgSize.exif_location.length);\n\n    var orientation = exif.get_orientation(exif_data);\n\n    if (orientation > 0) result.orientation = orientation;\n  }\n\n  return result;\n};\n","'use strict';\n\n/* eslint-disable consistent-return */\n\nvar str2arr      = require('../common').str2arr;\nvar sliceEq      = require('../common').sliceEq;\nvar readUInt16LE = require('../common').readUInt16LE;\n\nvar SIG_BM = str2arr('BM');\n\n\nmodule.exports = function (data) {\n  if (data.length < 26) return;\n\n  if (!sliceEq(data, 0, SIG_BM)) return;\n\n  return {\n    width:  readUInt16LE(data, 18),\n    height: readUInt16LE(data, 22),\n    type: 'bmp',\n    mime: 'image/bmp',\n    wUnits: 'px',\n    hUnits: 'px'\n  };\n};\n","'use strict';\n\n/* eslint-disable consistent-return */\n\nvar str2arr      = require('../common').str2arr;\nvar sliceEq      = require('../common').sliceEq;\nvar readUInt16LE = require('../common').readUInt16LE;\n\n\nvar SIG_GIF87a = str2arr('GIF87a');\nvar SIG_GIF89a = str2arr('GIF89a');\n\n\nmodule.exports = function (data) {\n  if (data.length < 10) return;\n\n  if (!sliceEq(data, 0, SIG_GIF87a) && !sliceEq(data, 0, SIG_GIF89a)) return;\n\n  return {\n    width:  readUInt16LE(data, 6),\n    height: readUInt16LE(data, 8),\n    type: 'gif',\n    mime: 'image/gif',\n    wUnits: 'px',\n    hUnits: 'px'\n  };\n};\n","'use strict';\n\n/* eslint-disable consistent-return */\n\nvar readUInt16LE = require('../common').readUInt16LE;\n\nvar HEADER = 0;\nvar TYPE_ICO = 1;\nvar INDEX_SIZE = 16;\n\n// Format specification:\n// https://en.wikipedia.org/wiki/ICO_(file_format)#Icon_resource_structure\nmodule.exports = function (data) {\n  var header = readUInt16LE(data, 0);\n  var type = readUInt16LE(data, 2);\n  var numImages = readUInt16LE(data, 4);\n\n  if (header !== HEADER || type !== TYPE_ICO || !numImages) {\n    return;\n  }\n\n  var variants = [];\n  var maxSize = { width: 0, height: 0 };\n\n  for (var i = 0; i < numImages; i++) {\n    var width = data[6 + INDEX_SIZE * i] || 256;\n    var height = data[6 + INDEX_SIZE * i + 1] || 256;\n    var size = { width: width, height: height };\n    variants.push(size);\n\n    if (width > maxSize.width || height > maxSize.height) {\n      maxSize = size;\n    }\n  }\n\n  return {\n    width: maxSize.width,\n    height: maxSize.height,\n    variants: variants,\n    type: 'ico',\n    mime: 'image/x-icon',\n    wUnits: 'px',\n    hUnits: 'px'\n  };\n};\n","'use strict';\n\n/* eslint-disable consistent-return */\n\nvar readUInt16BE = require('../common').readUInt16BE;\nvar str2arr      = require('../common').str2arr;\nvar sliceEq      = require('../common').sliceEq;\nvar exif         = require('../exif_utils');\n\n\nvar SIG_EXIF  = str2arr('Exif\\0\\0');\n\n\nmodule.exports = function (data) {\n  if (data.length < 2) return;\n\n  // first marker of the file MUST be 0xFFD8\n  if (data[0] !== 0xFF || data[1] !== 0xD8) return;\n\n  var offset = 2;\n\n  for (;;) {\n    if (data.length - offset < 2) return;\n    // not a JPEG marker\n    if (data[offset++] !== 0xFF) return;\n\n    var code = data[offset++];\n    var length;\n\n    // skip padding bytes\n    while (code === 0xFF) code = data[offset++];\n\n    // standalone markers, according to JPEG 1992,\n    // http://www.w3.org/Graphics/JPEG/itu-t81.pdf, see Table B.1\n    if ((0xD0 <= code && code <= 0xD9) || code === 0x01) {\n      length = 0;\n    } else if (0xC0 <= code && code <= 0xFE) {\n      // the rest of the unreserved markers\n      if (data.length - offset < 2) return;\n\n      length = readUInt16BE(data, offset) - 2;\n      offset += 2;\n    } else {\n      // unknown markers\n      return;\n    }\n\n    if (code === 0xD9 /* EOI */ || code === 0xDA /* SOS */) {\n      // end of the datastream\n      return;\n    }\n\n    var orientation;\n\n    // try to get orientation from Exif segment\n    if (code === 0xE1 && length >= 10 && sliceEq(data, offset, SIG_EXIF)) {\n      orientation = exif.get_orientation(data.slice(offset + 6, offset + length));\n    }\n\n    if (length >= 5 &&\n        (0xC0 <= code && code <= 0xCF) &&\n        code !== 0xC4 && code !== 0xC8 && code !== 0xCC) {\n\n      if (data.length - offset < length) return;\n\n      var result = {\n        width:  readUInt16BE(data, offset + 3),\n        height: readUInt16BE(data, offset + 1),\n        type:   'jpg',\n        mime:   'image/jpeg',\n        wUnits: 'px',\n        hUnits: 'px'\n      };\n\n      if (orientation > 0) {\n        result.orientation = orientation;\n      }\n\n      return result;\n    }\n\n    offset += length;\n  }\n};\n","'use strict';\n\n/* eslint-disable consistent-return */\n\nvar str2arr      = require('../common').str2arr;\nvar sliceEq      = require('../common').sliceEq;\nvar readUInt32BE = require('../common').readUInt32BE;\n\n\nvar SIG_PNG  = str2arr('\\x89PNG\\r\\n\\x1a\\n');\nvar SIG_IHDR = str2arr('IHDR');\n\n\nmodule.exports = function (data) {\n  if (data.length < 24) return;\n\n  // check PNG signature\n  if (!sliceEq(data, 0, SIG_PNG)) return;\n\n  // check that first chunk is IHDR\n  if (!sliceEq(data, 12, SIG_IHDR)) return;\n\n  return {\n    width:  readUInt32BE(data, 16),\n    height: readUInt32BE(data, 20),\n    type: 'png',\n    mime: 'image/png',\n    wUnits: 'px',\n    hUnits: 'px'\n  };\n};\n","'use strict';\n\n/* eslint-disable consistent-return */\n\nvar str2arr      = require('../common').str2arr;\nvar sliceEq      = require('../common').sliceEq;\nvar readUInt32BE = require('../common').readUInt32BE;\n\n\nvar SIG_8BPS  = str2arr('8BPS\\x00\\x01');\n\n\nmodule.exports = function (data) {\n  if (data.length < 6 + 16) return;\n\n  // signature + version\n  if (!sliceEq(data, 0, SIG_8BPS)) return;\n\n  return {\n    width:  readUInt32BE(data, 6 + 12),\n    height: readUInt32BE(data, 6 + 8),\n    type: 'psd',\n    mime: 'image/vnd.adobe.photoshop',\n    wUnits: 'px',\n    hUnits: 'px'\n  };\n};\n","'use strict';\n\n/* eslint-disable consistent-return */\n\nfunction isWhiteSpace(chr) {\n  return chr === 0x20 || chr === 0x09 || chr === 0x0D || chr === 0x0A;\n}\n\n// Filter NaN, Infinity, < 0\nfunction isFinitePositive(val) {\n  return typeof val === 'number' && isFinite(val) && val > 0;\n}\n\nfunction canBeSvg(buf) {\n  var i = 0, max = buf.length;\n\n  // byte order mark, https://github.com/nodeca/probe-image-size/issues/57\n  if (buf[0] === 0xEF && buf[1] === 0xBB && buf[2] === 0xBF) i = 3;\n\n  while (i < max && isWhiteSpace(buf[i])) i++;\n\n  if (i === max) return false;\n  return buf[i] === 0x3c; /* < */\n}\n\n\n// skip `<?` (comments), `<!` (directives, cdata, doctype),\n// looking for `<svg>` or `<NAMESPACE:svg>`\nvar SVG_HEADER_RE  = /<[-_.:a-zA-Z0-9][^>]*>/;\n\n// test if the top level element is svg + optional namespace,\n// used to skip svg embedded in html\nvar SVG_TAG_RE     = /^<([-_.:a-zA-Z0-9]+:)?svg\\s/;\n\nvar SVG_WIDTH_RE   = /[^-]\\bwidth=\"([^%]+?)\"|[^-]\\bwidth='([^%]+?)'/;\nvar SVG_HEIGHT_RE  = /\\bheight=\"([^%]+?)\"|\\bheight='([^%]+?)'/;\nvar SVG_VIEWBOX_RE = /\\bview[bB]ox=\"(.+?)\"|\\bview[bB]ox='(.+?)'/;\nvar SVG_UNITS_RE   = /in$|mm$|cm$|pt$|pc$|px$|em$|ex$/;\n\nfunction svgAttrs(str) {\n  var width   = str.match(SVG_WIDTH_RE);\n  var height  = str.match(SVG_HEIGHT_RE);\n  var viewbox = str.match(SVG_VIEWBOX_RE);\n\n  return {\n    width:   width && (width[1] || width[2]),\n    height:  height && (height[1] || height[2]),\n    viewbox: viewbox && (viewbox[1] || viewbox[2])\n  };\n}\n\n\nfunction units(str) {\n  if (!SVG_UNITS_RE.test(str)) return 'px';\n\n  return str.match(SVG_UNITS_RE)[0];\n}\n\n\nmodule.exports = function (data) {\n  if (!canBeSvg(data)) return;\n\n  var str = '';\n\n  for (var i = 0; i < data.length; i++) {\n    // 1. We can't rely on buffer features\n    // 2. Don't care about UTF16 because ascii is enougth for our goals\n    str += String.fromCharCode(data[i]);\n  }\n\n  // get top level element\n  var svgTag = (str.match(SVG_HEADER_RE) || [ '' ])[0];\n\n  // test if top level element is <svg>\n  if (!SVG_TAG_RE.test(svgTag)) return;\n\n  var attrs  = svgAttrs(svgTag);\n  var width  = parseFloat(attrs.width);\n  var height = parseFloat(attrs.height);\n\n  // Extract from direct values\n\n  if (attrs.width && attrs.height) {\n    if (!isFinitePositive(width) || !isFinitePositive(height)) return;\n\n    return {\n      width:  width,\n      height: height,\n      type:   'svg',\n      mime:   'image/svg+xml',\n      wUnits: units(attrs.width),\n      hUnits: units(attrs.height)\n    };\n  }\n\n  // Extract from viewbox\n\n  var parts = (attrs.viewbox || '').split(' ');\n  var viewbox = {\n    width:  parts[2],\n    height: parts[3]\n  };\n  var vbWidth  = parseFloat(viewbox.width);\n  var vbHeight = parseFloat(viewbox.height);\n\n  if (!isFinitePositive(vbWidth) || !isFinitePositive(vbHeight)) return;\n  if (units(viewbox.width) !== units(viewbox.height)) return;\n\n  var ratio = vbWidth / vbHeight;\n\n  if (attrs.width) {\n    if (!isFinitePositive(width)) return;\n\n    return {\n      width:  width,\n      height: width / ratio,\n      type:   'svg',\n      mime:   'image/svg+xml',\n      wUnits: units(attrs.width),\n      hUnits: units(attrs.width)\n    };\n  }\n\n  if (attrs.height) {\n    if (!isFinitePositive(height)) return;\n\n    return {\n      width:  height * ratio,\n      height: height,\n      type:   'svg',\n      mime:   'image/svg+xml',\n      wUnits: units(attrs.height),\n      hUnits: units(attrs.height)\n    };\n  }\n\n  return {\n    width:  vbWidth,\n    height: vbHeight,\n    type:   'svg',\n    mime:   'image/svg+xml',\n    wUnits: units(viewbox.width),\n    hUnits: units(viewbox.height)\n  };\n};\n","'use strict';\n\n/* eslint-disable consistent-return */\n\nvar str2arr = require('../common').str2arr;\nvar sliceEq = require('../common').sliceEq;\nvar readUInt16LE = require('../common').readUInt16LE;\nvar readUInt16BE = require('../common').readUInt16BE;\nvar readUInt32LE = require('../common').readUInt32LE;\nvar readUInt32BE = require('../common').readUInt32BE;\n\n\nvar SIG_1 = str2arr('II\\x2A\\0');\nvar SIG_2 = str2arr('MM\\0\\x2A');\n\n\nfunction readUInt16(buffer, offset, is_big_endian) {\n  return is_big_endian ? readUInt16BE(buffer, offset) : readUInt16LE(buffer, offset);\n}\n\nfunction readUInt32(buffer, offset, is_big_endian) {\n  return is_big_endian ? readUInt32BE(buffer, offset) : readUInt32LE(buffer, offset);\n}\n\nfunction readIFDValue(data, data_offset, is_big_endian) {\n  var type       = readUInt16(data, data_offset + 2, is_big_endian);\n  var values     = readUInt32(data, data_offset + 4, is_big_endian);\n\n  if (values !== 1 || (type !== 3 && type !== 4)) return null;\n\n  if (type === 3) {\n    return readUInt16(data, data_offset + 8, is_big_endian);\n  }\n\n  return readUInt32(data, data_offset + 8, is_big_endian);\n}\n\nmodule.exports = function (data) {\n  if (data.length < 8) return;\n\n  // check TIFF signature\n  if (!sliceEq(data, 0, SIG_1) && !sliceEq(data, 0, SIG_2)) return;\n\n  var is_big_endian = (data[0] === 77 /* 'MM' */);\n  var count = readUInt32(data, 4, is_big_endian) - 8;\n\n  if (count < 0) return;\n\n  // skip until IFD\n  var offset = count + 8;\n\n  if (data.length - offset < 2) return;\n\n  // read number of IFD entries\n  var ifd_size = readUInt16(data, offset + 0, is_big_endian) * 12;\n\n  if (ifd_size <= 0) return;\n\n  offset += 2;\n\n  // read all IFD entries\n  if (data.length - offset < ifd_size) return;\n\n  var i, width, height, tag;\n\n  for (i = 0; i < ifd_size; i += 12) {\n    tag = readUInt16(data, offset + i, is_big_endian);\n\n    if (tag === 256) {\n      width = readIFDValue(data, offset + i, is_big_endian);\n    } else if (tag === 257) {\n      height = readIFDValue(data, offset + i, is_big_endian);\n    }\n  }\n\n  if (width && height) {\n    return {\n      width:  width,\n      height: height,\n      type:   'tiff',\n      mime:   'image/tiff',\n      wUnits: 'px',\n      hUnits: 'px'\n    };\n  }\n};\n","'use strict';\n\n/* eslint-disable no-bitwise */\n/* eslint-disable consistent-return */\n\nvar str2arr      = require('../common').str2arr;\nvar sliceEq      = require('../common').sliceEq;\nvar readUInt16LE = require('../common').readUInt16LE;\nvar readUInt32LE = require('../common').readUInt32LE;\nvar exif         = require('../exif_utils');\n\n\nvar SIG_RIFF = str2arr('RIFF');\nvar SIG_WEBP = str2arr('WEBP');\n\n\nfunction parseVP8(data, offset) {\n  if (data[offset + 3] !== 0x9D || data[offset + 4] !== 0x01 || data[offset + 5] !== 0x2A) {\n    // bad code block signature\n    return;\n  }\n\n  return {\n    width:  readUInt16LE(data, offset + 6) & 0x3FFF,\n    height: readUInt16LE(data, offset + 8) & 0x3FFF,\n    type:   'webp',\n    mime:   'image/webp',\n    wUnits: 'px',\n    hUnits: 'px'\n  };\n}\n\n\nfunction parseVP8L(data, offset) {\n  if (data[offset] !== 0x2F) return;\n\n  var bits = readUInt32LE(data, offset + 1);\n\n  return {\n    width:  (bits & 0x3FFF) + 1,\n    height: ((bits >> 14) & 0x3FFF) + 1,\n    type:   'webp',\n    mime:   'image/webp',\n    wUnits: 'px',\n    hUnits: 'px'\n  };\n}\n\n\nfunction parseVP8X(data, offset) {\n  return  {\n    // TODO: replace with `data.readUIntLE(8, 3) + 1`\n    //       when 0.10 support is dropped\n    width:  ((data[offset + 6] << 16) | (data[offset + 5] << 8) | data[offset + 4]) + 1,\n    height: ((data[offset + 9] << offset) | (data[offset + 8] << 8) | data[offset + 7]) + 1,\n    type:   'webp',\n    mime:   'image/webp',\n    wUnits: 'px',\n    hUnits: 'px'\n  };\n}\n\n\nmodule.exports = function (data) {\n  if (data.length < 16) return;\n\n  // check /^RIFF....WEBPVP8([ LX])$/ signature\n  if (!sliceEq(data, 0, SIG_RIFF) && !sliceEq(data, 8, SIG_WEBP)) return;\n\n  var offset = 12;\n  var result = null;\n  var exif_orientation = 0;\n  var fileLength = readUInt32LE(data, 4) + 8;\n\n  if (fileLength > data.length) return;\n\n  while (offset + 8 < fileLength) {\n    if (data[offset] === 0) {\n      // after each chunk of odd size there should be 0 byte of padding, skip those\n      offset++;\n      continue;\n    }\n\n    var header = String.fromCharCode.apply(null, data.slice(offset, offset + 4));\n    var length = readUInt32LE(data, offset + 4);\n\n    if (header === 'VP8 ' && length >= 10) {\n      result = result || parseVP8(data, offset + 8);\n    } else if (header === 'VP8L' && length >= 9) {\n      result = result || parseVP8L(data, offset + 8);\n    } else if (header === 'VP8X' && length >= 10) {\n      result = result || parseVP8X(data, offset + 8);\n    } else if (header === 'EXIF') {\n      exif_orientation = exif.get_orientation(data.slice(offset + 8, offset + 8 + length));\n\n      // exif is the last chunk we care about, stop after it\n      offset = Infinity;\n    }\n\n    offset += 8 + length;\n  }\n\n  if (!result) return;\n\n  if (exif_orientation > 0) {\n    result.orientation = exif_orientation;\n  }\n\n  return result;\n};\n","'use strict';\n\n\nmodule.exports = {\n  avif: require('./parse_sync/avif'),\n  bmp:  require('./parse_sync/bmp'),\n  gif:  require('./parse_sync/gif'),\n  ico:  require('./parse_sync/ico'),\n  jpeg: require('./parse_sync/jpeg'),\n  png:  require('./parse_sync/png'),\n  psd:  require('./parse_sync/psd'),\n  svg:  require('./parse_sync/svg'),\n  tiff: require('./parse_sync/tiff'),\n  webp: require('./parse_sync/webp')\n};\n","'use strict';\n\n\nvar parsers = require('./lib/parsers_sync');\n\n\nfunction probeBuffer(buffer) {\n  var parser_names = Object.keys(parsers);\n\n  for (var i = 0; i < parser_names.length; i++) {\n    var result = parsers[parser_names[i]](buffer);\n\n    if (result) return result;\n  }\n\n  return null;\n}\n\n\n///////////////////////////////////////////////////////////////////////\n// Exports\n//\n\nmodule.exports = function get_image_size(src) {\n  return probeBuffer(src);\n};\n\nmodule.exports.parsers = parsers;\n"],"names":["Transform","streamParser","ParserStream","call","this","readableObjectMode","ProbeError","message","code","statusCode","Error","captureStackTrace","constructor","name","prototype","Object","create","exports","src","start","dest","i","j","length","str","format","arr","push","parseInt","slice","charCodeAt","data","offset","error","err","utf8_decode","decodeURIComponent","escape","_","ExifParser","jpeg_bin","exif_start","exif_end","input","subarray","sig","String","fromCharCode","apply","big_endian","each","on_entry","aborted","read_uint32","ifds_to_read","id","shift","scan_ifd","read_uint16","d","is_subifd_link","ifd","tag","exif_format_length","exif_format_read","v","ifd_no","entry_count","count","comp_length","data_length","data_offset","value","comp_offset","item","Array","isArray","Number","isInteger","is_big_endian","entry_offset","module","get_orientation","orientation","entry","readUInt16BE","readUInt32BE","unbox","size","boxtype","end","scan_ipco","sandbox","box","sizes","width","height","transforms","type","readUIntBE","result","scan_iloc","offset_size","length_size","base_offset_size","item_count","item_ID","data_reference_index","base_offset","extent_count","first_extent_offset","first_extent_length","item_loc","scan_iinf","item_id","item_name","pos","item_inf","scan_iprp","readSizeFromMeta","scan_meta","maxWidthSize","maxHeightSize","maxSize","reduce","a","b","forEach","transform","rotate_ccw","mirror_vert","exif_location","Exif","variants","getMimeType","brand","compat","mif1","msf1","miaf","mime","avif","avis","heic","heix","hevc","hevx","heis","str2arr","sliceEq","exif","SIG_FTYP","firstBox","fileType","meta","imgSize","wUnits","hUnits","sig_offset","exif_data","readUInt16LE","SIG_BM","SIG_GIF87a","SIG_GIF89a","header","numImages","SIG_EXIF","SIG_PNG","SIG_IHDR","SIG_8BPS","isFinitePositive","val","isFinite","SVG_HEADER_RE","SVG_TAG_RE","SVG_WIDTH_RE","SVG_HEIGHT_RE","SVG_VIEWBOX_RE","SVG_UNITS_RE","units","test","match","buf","chr","max","canBeSvg","svgTag","attrs","viewbox","svgAttrs","parseFloat","parts","split","vbWidth","vbHeight","ratio","readUInt32LE","SIG_1","SIG_2","readUInt16","buffer","readUInt32","readIFDValue","ifd_size","SIG_RIFF","SIG_WEBP","parseVP8","parseVP8L","bits","parseVP8X","exif_orientation","fileLength","Infinity","bmp","gif","ico","jpeg","png","psd","svg","tiff","webp","parsers","parser_names","keys","probeBuffer"],"sourceRoot":""}