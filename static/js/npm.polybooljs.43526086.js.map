{"version":3,"file":"js/npm.polybooljs.43526086.js","mappings":"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","sources":["webpack://wellcast/./node_modules/polybooljs/index.js","webpack://wellcast/./node_modules/polybooljs/lib/build-log.js","webpack://wellcast/./node_modules/polybooljs/lib/epsilon.js","webpack://wellcast/./node_modules/polybooljs/lib/geojson.js","webpack://wellcast/./node_modules/polybooljs/lib/intersecter.js","webpack://wellcast/./node_modules/polybooljs/lib/linked-list.js","webpack://wellcast/./node_modules/polybooljs/lib/segment-chainer.js","webpack://wellcast/./node_modules/polybooljs/lib/segment-selector.js"],"sourcesContent":["/*\n * @copyright 2016 Sean Connelly (@voidqk), http://syntheti.cc\n * @license MIT\n * @preserve Project Home: https://github.com/voidqk/polybooljs\n */\n\nvar BuildLog = require('./lib/build-log');\nvar Epsilon = require('./lib/epsilon');\nvar Intersecter = require('./lib/intersecter');\nvar SegmentChainer = require('./lib/segment-chainer');\nvar SegmentSelector = require('./lib/segment-selector');\nvar GeoJSON = require('./lib/geojson');\n\nvar buildLog = false;\nvar epsilon = Epsilon();\n\nvar PolyBool;\nPolyBool = {\n\t// getter/setter for buildLog\n\tbuildLog: function(bl){\n\t\tif (bl === true)\n\t\t\tbuildLog = BuildLog();\n\t\telse if (bl === false)\n\t\t\tbuildLog = false;\n\t\treturn buildLog === false ? false : buildLog.list;\n\t},\n\t// getter/setter for epsilon\n\tepsilon: function(v){\n\t\treturn epsilon.epsilon(v);\n\t},\n\n\t// core API\n\tsegments: function(poly){\n\t\tvar i = Intersecter(true, epsilon, buildLog);\n\t\tpoly.regions.forEach(i.addRegion);\n\t\treturn {\n\t\t\tsegments: i.calculate(poly.inverted),\n\t\t\tinverted: poly.inverted\n\t\t};\n\t},\n\tcombine: function(segments1, segments2){\n\t\tvar i3 = Intersecter(false, epsilon, buildLog);\n\t\treturn {\n\t\t\tcombined: i3.calculate(\n\t\t\t\tsegments1.segments, segments1.inverted,\n\t\t\t\tsegments2.segments, segments2.inverted\n\t\t\t),\n\t\t\tinverted1: segments1.inverted,\n\t\t\tinverted2: segments2.inverted\n\t\t};\n\t},\n\tselectUnion: function(combined){\n\t\treturn {\n\t\t\tsegments: SegmentSelector.union(combined.combined, buildLog),\n\t\t\tinverted: combined.inverted1 || combined.inverted2\n\t\t}\n\t},\n\tselectIntersect: function(combined){\n\t\treturn {\n\t\t\tsegments: SegmentSelector.intersect(combined.combined, buildLog),\n\t\t\tinverted: combined.inverted1 && combined.inverted2\n\t\t}\n\t},\n\tselectDifference: function(combined){\n\t\treturn {\n\t\t\tsegments: SegmentSelector.difference(combined.combined, buildLog),\n\t\t\tinverted: combined.inverted1 && !combined.inverted2\n\t\t}\n\t},\n\tselectDifferenceRev: function(combined){\n\t\treturn {\n\t\t\tsegments: SegmentSelector.differenceRev(combined.combined, buildLog),\n\t\t\tinverted: !combined.inverted1 && combined.inverted2\n\t\t}\n\t},\n\tselectXor: function(combined){\n\t\treturn {\n\t\t\tsegments: SegmentSelector.xor(combined.combined, buildLog),\n\t\t\tinverted: combined.inverted1 !== combined.inverted2\n\t\t}\n\t},\n\tpolygon: function(segments){\n\t\treturn {\n\t\t\tregions: SegmentChainer(segments.segments, epsilon, buildLog),\n\t\t\tinverted: segments.inverted\n\t\t};\n\t},\n\n\t// GeoJSON converters\n\tpolygonFromGeoJSON: function(geojson){\n\t\treturn GeoJSON.toPolygon(PolyBool, geojson);\n\t},\n\tpolygonToGeoJSON: function(poly){\n\t\treturn GeoJSON.fromPolygon(PolyBool, epsilon, poly);\n\t},\n\n\t// helper functions for common operations\n\tunion: function(poly1, poly2){\n\t\treturn operate(poly1, poly2, PolyBool.selectUnion);\n\t},\n\tintersect: function(poly1, poly2){\n\t\treturn operate(poly1, poly2, PolyBool.selectIntersect);\n\t},\n\tdifference: function(poly1, poly2){\n\t\treturn operate(poly1, poly2, PolyBool.selectDifference);\n\t},\n\tdifferenceRev: function(poly1, poly2){\n\t\treturn operate(poly1, poly2, PolyBool.selectDifferenceRev);\n\t},\n\txor: function(poly1, poly2){\n\t\treturn operate(poly1, poly2, PolyBool.selectXor);\n\t}\n};\n\nfunction operate(poly1, poly2, selector){\n\tvar seg1 = PolyBool.segments(poly1);\n\tvar seg2 = PolyBool.segments(poly2);\n\tvar comb = PolyBool.combine(seg1, seg2);\n\tvar seg3 = selector(comb);\n\treturn PolyBool.polygon(seg3);\n}\n\nif (typeof window === 'object')\n\twindow.PolyBool = PolyBool;\n\nmodule.exports = PolyBool;\n","// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// used strictly for logging the processing of the algorithm... only useful if you intend on\n// looking under the covers (for pretty UI's or debugging)\n//\n\nfunction BuildLog(){\n\tvar my;\n\tvar nextSegmentId = 0;\n\tvar curVert = false;\n\n\tfunction push(type, data){\n\t\tmy.list.push({\n\t\t\ttype: type,\n\t\t\tdata: data ? JSON.parse(JSON.stringify(data)) : void 0\n\t\t});\n\t\treturn my;\n\t}\n\n\tmy = {\n\t\tlist: [],\n\t\tsegmentId: function(){\n\t\t\treturn nextSegmentId++;\n\t\t},\n\t\tcheckIntersection: function(seg1, seg2){\n\t\t\treturn push('check', { seg1: seg1, seg2: seg2 });\n\t\t},\n\t\tsegmentChop: function(seg, end){\n\t\t\tpush('div_seg', { seg: seg, pt: end });\n\t\t\treturn push('chop', { seg: seg, pt: end });\n\t\t},\n\t\tstatusRemove: function(seg){\n\t\t\treturn push('pop_seg', { seg: seg });\n\t\t},\n\t\tsegmentUpdate: function(seg){\n\t\t\treturn push('seg_update', { seg: seg });\n\t\t},\n\t\tsegmentNew: function(seg, primary){\n\t\t\treturn push('new_seg', { seg: seg, primary: primary });\n\t\t},\n\t\tsegmentRemove: function(seg){\n\t\t\treturn push('rem_seg', { seg: seg });\n\t\t},\n\t\ttempStatus: function(seg, above, below){\n\t\t\treturn push('temp_status', { seg: seg, above: above, below: below });\n\t\t},\n\t\trewind: function(seg){\n\t\t\treturn push('rewind', { seg: seg });\n\t\t},\n\t\tstatus: function(seg, above, below){\n\t\t\treturn push('status', { seg: seg, above: above, below: below });\n\t\t},\n\t\tvert: function(x){\n\t\t\tif (x === curVert)\n\t\t\t\treturn my;\n\t\t\tcurVert = x;\n\t\t\treturn push('vert', { x: x });\n\t\t},\n\t\tlog: function(data){\n\t\t\tif (typeof data !== 'string')\n\t\t\t\tdata = JSON.stringify(data, false, '  ');\n\t\t\treturn push('log', { txt: data });\n\t\t},\n\t\treset: function(){\n\t\t\treturn push('reset');\n\t\t},\n\t\tselected: function(segs){\n\t\t\treturn push('selected', { segs: segs });\n\t\t},\n\t\tchainStart: function(seg){\n\t\t\treturn push('chain_start', { seg: seg });\n\t\t},\n\t\tchainRemoveHead: function(index, pt){\n\t\t\treturn push('chain_rem_head', { index: index, pt: pt });\n\t\t},\n\t\tchainRemoveTail: function(index, pt){\n\t\t\treturn push('chain_rem_tail', { index: index, pt: pt });\n\t\t},\n\t\tchainNew: function(pt1, pt2){\n\t\t\treturn push('chain_new', { pt1: pt1, pt2: pt2 });\n\t\t},\n\t\tchainMatch: function(index){\n\t\t\treturn push('chain_match', { index: index });\n\t\t},\n\t\tchainClose: function(index){\n\t\t\treturn push('chain_close', { index: index });\n\t\t},\n\t\tchainAddHead: function(index, pt){\n\t\t\treturn push('chain_add_head', { index: index, pt: pt });\n\t\t},\n\t\tchainAddTail: function(index, pt){\n\t\t\treturn push('chain_add_tail', { index: index, pt: pt, });\n\t\t},\n\t\tchainConnect: function(index1, index2){\n\t\t\treturn push('chain_con', { index1: index1, index2: index2 });\n\t\t},\n\t\tchainReverse: function(index){\n\t\t\treturn push('chain_rev', { index: index });\n\t\t},\n\t\tchainJoin: function(index1, index2){\n\t\t\treturn push('chain_join', { index1: index1, index2: index2 });\n\t\t},\n\t\tdone: function(){\n\t\t\treturn push('done');\n\t\t}\n\t};\n\treturn my;\n}\n\nmodule.exports = BuildLog;\n","// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// provides the raw computation functions that takes epsilon into account\n//\n// zero is defined to be between (-epsilon, epsilon) exclusive\n//\n\nfunction Epsilon(eps){\n\tif (typeof eps !== 'number')\n\t\teps = 0.0000000001; // sane default? sure why not\n\tvar my = {\n\t\tepsilon: function(v){\n\t\t\tif (typeof v === 'number')\n\t\t\t\teps = v;\n\t\t\treturn eps;\n\t\t},\n\t\tpointAboveOrOnLine: function(pt, left, right){\n\t\t\tvar Ax = left[0];\n\t\t\tvar Ay = left[1];\n\t\t\tvar Bx = right[0];\n\t\t\tvar By = right[1];\n\t\t\tvar Cx = pt[0];\n\t\t\tvar Cy = pt[1];\n\t\t\treturn (Bx - Ax) * (Cy - Ay) - (By - Ay) * (Cx - Ax) >= -eps;\n\t\t},\n\t\tpointBetween: function(p, left, right){\n\t\t\t// p must be collinear with left->right\n\t\t\t// returns false if p == left, p == right, or left == right\n\t\t\tvar d_py_ly = p[1] - left[1];\n\t\t\tvar d_rx_lx = right[0] - left[0];\n\t\t\tvar d_px_lx = p[0] - left[0];\n\t\t\tvar d_ry_ly = right[1] - left[1];\n\n\t\t\tvar dot = d_px_lx * d_rx_lx + d_py_ly * d_ry_ly;\n\t\t\t// if `dot` is 0, then `p` == `left` or `left` == `right` (reject)\n\t\t\t// if `dot` is less than 0, then `p` is to the left of `left` (reject)\n\t\t\tif (dot < eps)\n\t\t\t\treturn false;\n\n\t\t\tvar sqlen = d_rx_lx * d_rx_lx + d_ry_ly * d_ry_ly;\n\t\t\t// if `dot` > `sqlen`, then `p` is to the right of `right` (reject)\n\t\t\t// therefore, if `dot - sqlen` is greater than 0, then `p` is to the right of `right` (reject)\n\t\t\tif (dot - sqlen > -eps)\n\t\t\t\treturn false;\n\n\t\t\treturn true;\n\t\t},\n\t\tpointsSameX: function(p1, p2){\n\t\t\treturn Math.abs(p1[0] - p2[0]) < eps;\n\t\t},\n\t\tpointsSameY: function(p1, p2){\n\t\t\treturn Math.abs(p1[1] - p2[1]) < eps;\n\t\t},\n\t\tpointsSame: function(p1, p2){\n\t\t\treturn my.pointsSameX(p1, p2) && my.pointsSameY(p1, p2);\n\t\t},\n\t\tpointsCompare: function(p1, p2){\n\t\t\t// returns -1 if p1 is smaller, 1 if p2 is smaller, 0 if equal\n\t\t\tif (my.pointsSameX(p1, p2))\n\t\t\t\treturn my.pointsSameY(p1, p2) ? 0 : (p1[1] < p2[1] ? -1 : 1);\n\t\t\treturn p1[0] < p2[0] ? -1 : 1;\n\t\t},\n\t\tpointsCollinear: function(pt1, pt2, pt3){\n\t\t\t// does pt1->pt2->pt3 make a straight line?\n\t\t\t// essentially this is just checking to see if the slope(pt1->pt2) === slope(pt2->pt3)\n\t\t\t// if slopes are equal, then they must be collinear, because they share pt2\n\t\t\tvar dx1 = pt1[0] - pt2[0];\n\t\t\tvar dy1 = pt1[1] - pt2[1];\n\t\t\tvar dx2 = pt2[0] - pt3[0];\n\t\t\tvar dy2 = pt2[1] - pt3[1];\n\t\t\treturn Math.abs(dx1 * dy2 - dx2 * dy1) < eps;\n\t\t},\n\t\tlinesIntersect: function(a0, a1, b0, b1){\n\t\t\t// returns false if the lines are coincident (e.g., parallel or on top of each other)\n\t\t\t//\n\t\t\t// returns an object if the lines intersect:\n\t\t\t//   {\n\t\t\t//     pt: [x, y],    where the intersection point is at\n\t\t\t//     alongA: where intersection point is along A,\n\t\t\t//     alongB: where intersection point is along B\n\t\t\t//   }\n\t\t\t//\n\t\t\t//  alongA and alongB will each be one of: -2, -1, 0, 1, 2\n\t\t\t//\n\t\t\t//  with the following meaning:\n\t\t\t//\n\t\t\t//    -2   intersection point is before segment's first point\n\t\t\t//    -1   intersection point is directly on segment's first point\n\t\t\t//     0   intersection point is between segment's first and second points (exclusive)\n\t\t\t//     1   intersection point is directly on segment's second point\n\t\t\t//     2   intersection point is after segment's second point\n\t\t\tvar adx = a1[0] - a0[0];\n\t\t\tvar ady = a1[1] - a0[1];\n\t\t\tvar bdx = b1[0] - b0[0];\n\t\t\tvar bdy = b1[1] - b0[1];\n\n\t\t\tvar axb = adx * bdy - ady * bdx;\n\t\t\tif (Math.abs(axb) < eps)\n\t\t\t\treturn false; // lines are coincident\n\n\t\t\tvar dx = a0[0] - b0[0];\n\t\t\tvar dy = a0[1] - b0[1];\n\n\t\t\tvar A = (bdx * dy - bdy * dx) / axb;\n\t\t\tvar B = (adx * dy - ady * dx) / axb;\n\n\t\t\tvar ret = {\n\t\t\t\talongA: 0,\n\t\t\t\talongB: 0,\n\t\t\t\tpt: [\n\t\t\t\t\ta0[0] + A * adx,\n\t\t\t\t\ta0[1] + A * ady\n\t\t\t\t]\n\t\t\t};\n\n\t\t\t// categorize where intersection point is along A and B\n\n\t\t\tif (A <= -eps)\n\t\t\t\tret.alongA = -2;\n\t\t\telse if (A < eps)\n\t\t\t\tret.alongA = -1;\n\t\t\telse if (A - 1 <= -eps)\n\t\t\t\tret.alongA = 0;\n\t\t\telse if (A - 1 < eps)\n\t\t\t\tret.alongA = 1;\n\t\t\telse\n\t\t\t\tret.alongA = 2;\n\n\t\t\tif (B <= -eps)\n\t\t\t\tret.alongB = -2;\n\t\t\telse if (B < eps)\n\t\t\t\tret.alongB = -1;\n\t\t\telse if (B - 1 <= -eps)\n\t\t\t\tret.alongB = 0;\n\t\t\telse if (B - 1 < eps)\n\t\t\t\tret.alongB = 1;\n\t\t\telse\n\t\t\t\tret.alongB = 2;\n\n\t\t\treturn ret;\n\t\t},\n\t\tpointInsideRegion: function(pt, region){\n\t\t\tvar x = pt[0];\n\t\t\tvar y = pt[1];\n\t\t\tvar last_x = region[region.length - 1][0];\n\t\t\tvar last_y = region[region.length - 1][1];\n\t\t\tvar inside = false;\n\t\t\tfor (var i = 0; i < region.length; i++){\n\t\t\t\tvar curr_x = region[i][0];\n\t\t\t\tvar curr_y = region[i][1];\n\n\t\t\t\t// if y is between curr_y and last_y, and\n\t\t\t\t// x is to the right of the boundary created by the line\n\t\t\t\tif ((curr_y - y > eps) != (last_y - y > eps) &&\n\t\t\t\t\t(last_x - curr_x) * (y - curr_y) / (last_y - curr_y) + curr_x - x > eps)\n\t\t\t\t\tinside = !inside\n\n\t\t\t\tlast_x = curr_x;\n\t\t\t\tlast_y = curr_y;\n\t\t\t}\n\t\t\treturn inside;\n\t\t}\n\t};\n\treturn my;\n}\n\nmodule.exports = Epsilon;\n","// (c) Copyright 2017, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// convert between PolyBool polygon format and GeoJSON formats (Polygon and MultiPolygon)\n//\n\nvar GeoJSON = {\n\t// convert a GeoJSON object to a PolyBool polygon\n\ttoPolygon: function(PolyBool, geojson){\n\n\t\t// converts list of LineString's to segments\n\t\tfunction GeoPoly(coords){\n\t\t\t// check for empty coords\n\t\t\tif (coords.length <= 0)\n\t\t\t\treturn PolyBool.segments({ inverted: false, regions: [] });\n\n\t\t\t// convert LineString to segments\n\t\t\tfunction LineString(ls){\n\t\t\t\t// remove tail which should be the same as head\n\t\t\t\tvar reg = ls.slice(0, ls.length - 1);\n\t\t\t\treturn PolyBool.segments({ inverted: false, regions: [reg] });\n\t\t\t}\n\n\t\t\t// the first LineString is considered the outside\n\t\t\tvar out = LineString(coords[0]);\n\n\t\t\t// the rest of the LineStrings are considered interior holes, so subtract them from the\n\t\t\t// current result\n\t\t\tfor (var i = 1; i < coords.length; i++)\n\t\t\t\tout = PolyBool.selectDifference(PolyBool.combine(out, LineString(coords[i])));\n\n\t\t\treturn out;\n\t\t}\n\n\t\tif (geojson.type === 'Polygon'){\n\t\t\t// single polygon, so just convert it and we're done\n\t\t\treturn PolyBool.polygon(GeoPoly(geojson.coordinates));\n\t\t}\n\t\telse if (geojson.type === 'MultiPolygon'){\n\t\t\t// multiple polygons, so union all the polygons together\n\t\t\tvar out = PolyBool.segments({ inverted: false, regions: [] });\n\t\t\tfor (var i = 0; i < geojson.coordinates.length; i++)\n\t\t\t\tout = PolyBool.selectUnion(PolyBool.combine(out, GeoPoly(geojson.coordinates[i])));\n\t\t\treturn PolyBool.polygon(out);\n\t\t}\n\t\tthrow new Error('PolyBool: Cannot convert GeoJSON object to PolyBool polygon');\n\t},\n\n\t// convert a PolyBool polygon to a GeoJSON object\n\tfromPolygon: function(PolyBool, eps, poly){\n\t\t// make sure out polygon is clean\n\t\tpoly = PolyBool.polygon(PolyBool.segments(poly));\n\n\t\t// test if r1 is inside r2\n\t\tfunction regionInsideRegion(r1, r2){\n\t\t\t// we're guaranteed no lines intersect (because the polygon is clean), but a vertex\n\t\t\t// could be on the edge -- so we just average pt[0] and pt[1] to produce a point on the\n\t\t\t// edge of the first line, which cannot be on an edge\n\t\t\treturn eps.pointInsideRegion([\n\t\t\t\t(r1[0][0] + r1[1][0]) * 0.5,\n\t\t\t\t(r1[0][1] + r1[1][1]) * 0.5\n\t\t\t], r2);\n\t\t}\n\n\t\t// calculate inside heirarchy\n\t\t//\n\t\t//  _____________________   _______    roots -> A       -> F\n\t\t// |          A          | |   F   |            |          |\n\t\t// |  _______   _______  | |  ___  |            +-- B      +-- G\n\t\t// | |   B   | |   C   | | | |   | |            |   |\n\t\t// | |  ___  | |  ___  | | | |   | |            |   +-- D\n\t\t// | | | D | | | | E | | | | | G | |            |\n\t\t// | | |___| | | |___| | | | |   | |            +-- C\n\t\t// | |_______| |_______| | | |___| |                |\n\t\t// |_____________________| |_______|                +-- E\n\n\t\tfunction newNode(region){\n\t\t\treturn {\n\t\t\t\tregion: region,\n\t\t\t\tchildren: []\n\t\t\t};\n\t\t}\n\n\t\tvar roots = newNode(null);\n\n\t\tfunction addChild(root, region){\n\t\t\t// first check if we're inside any children\n\t\t\tfor (var i = 0; i < root.children.length; i++){\n\t\t\t\tvar child = root.children[i];\n\t\t\t\tif (regionInsideRegion(region, child.region)){\n\t\t\t\t\t// we are, so insert inside them instead\n\t\t\t\t\taddChild(child, region);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// not inside any children, so check to see if any children are inside us\n\t\t\tvar node = newNode(region);\n\t\t\tfor (var i = 0; i < root.children.length; i++){\n\t\t\t\tvar child = root.children[i];\n\t\t\t\tif (regionInsideRegion(child.region, region)){\n\t\t\t\t\t// oops... move the child beneath us, and remove them from root\n\t\t\t\t\tnode.children.push(child);\n\t\t\t\t\troot.children.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// now we can add ourselves\n\t\t\troot.children.push(node);\n\t\t}\n\n\t\t// add all regions to the root\n\t\tfor (var i = 0; i < poly.regions.length; i++){\n\t\t\tvar region = poly.regions[i];\n\t\t\tif (region.length < 3) // regions must have at least 3 points (sanity check)\n\t\t\t\tcontinue;\n\t\t\taddChild(roots, region);\n\t\t}\n\n\t\t// with our heirarchy, we can distinguish between exterior borders, and interior holes\n\t\t// the root nodes are exterior, children are interior, children's children are exterior,\n\t\t// children's children's children are interior, etc\n\n\t\t// while we're at it, exteriors are counter-clockwise, and interiors are clockwise\n\n\t\tfunction forceWinding(region, clockwise){\n\t\t\t// first, see if we're clockwise or counter-clockwise\n\t\t\t// https://en.wikipedia.org/wiki/Shoelace_formula\n\t\t\tvar winding = 0;\n\t\t\tvar last_x = region[region.length - 1][0];\n\t\t\tvar last_y = region[region.length - 1][1];\n\t\t\tvar copy = [];\n\t\t\tfor (var i = 0; i < region.length; i++){\n\t\t\t\tvar curr_x = region[i][0];\n\t\t\t\tvar curr_y = region[i][1];\n\t\t\t\tcopy.push([curr_x, curr_y]); // create a copy while we're at it\n\t\t\t\twinding += curr_y * last_x - curr_x * last_y;\n\t\t\t\tlast_x = curr_x;\n\t\t\t\tlast_y = curr_y;\n\t\t\t}\n\t\t\t// this assumes Cartesian coordinates (Y is positive going up)\n\t\t\tvar isclockwise = winding < 0;\n\t\t\tif (isclockwise !== clockwise)\n\t\t\t\tcopy.reverse();\n\t\t\t// while we're here, the last point must be the first point...\n\t\t\tcopy.push([copy[0][0], copy[0][1]]);\n\t\t\treturn copy;\n\t\t}\n\n\t\tvar geopolys = [];\n\n\t\tfunction addExterior(node){\n\t\t\tvar poly = [forceWinding(node.region, false)];\n\t\t\tgeopolys.push(poly);\n\t\t\t// children of exteriors are interior\n\t\t\tfor (var i = 0; i < node.children.length; i++)\n\t\t\t\tpoly.push(getInterior(node.children[i]));\n\t\t}\n\n\t\tfunction getInterior(node){\n\t\t\t// children of interiors are exterior\n\t\t\tfor (var i = 0; i < node.children.length; i++)\n\t\t\t\taddExterior(node.children[i]);\n\t\t\t// return the clockwise interior\n\t\t\treturn forceWinding(node.region, true);\n\t\t}\n\n\t\t// root nodes are exterior\n\t\tfor (var i = 0; i < roots.children.length; i++)\n\t\t\taddExterior(roots.children[i]);\n\n\t\t// lastly, construct the approrpriate GeoJSON object\n\n\t\tif (geopolys.length <= 0) // empty GeoJSON Polygon\n\t\t\treturn { type: 'Polygon', coordinates: [] };\n\t\tif (geopolys.length == 1) // use a GeoJSON Polygon\n\t\t\treturn { type: 'Polygon', coordinates: geopolys[0] };\n\t\treturn { // otherwise, use a GeoJSON MultiPolygon\n\t\t\ttype: 'MultiPolygon',\n\t\t\tcoordinates: geopolys\n\t\t};\n\t}\n};\n\nmodule.exports = GeoJSON;\n","// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// this is the core work-horse\n//\n\nvar LinkedList = require('./linked-list');\n\nfunction Intersecter(selfIntersection, eps, buildLog){\n\t// selfIntersection is true/false depending on the phase of the overall algorithm\n\n\t//\n\t// segment creation\n\t//\n\n\tfunction segmentNew(start, end){\n\t\treturn {\n\t\t\tid: buildLog ? buildLog.segmentId() : -1,\n\t\t\tstart: start,\n\t\t\tend: end,\n\t\t\tmyFill: {\n\t\t\t\tabove: null, // is there fill above us?\n\t\t\t\tbelow: null  // is there fill below us?\n\t\t\t},\n\t\t\totherFill: null\n\t\t};\n\t}\n\n\tfunction segmentCopy(start, end, seg){\n\t\treturn {\n\t\t\tid: buildLog ? buildLog.segmentId() : -1,\n\t\t\tstart: start,\n\t\t\tend: end,\n\t\t\tmyFill: {\n\t\t\t\tabove: seg.myFill.above,\n\t\t\t\tbelow: seg.myFill.below\n\t\t\t},\n\t\t\totherFill: null\n\t\t};\n\t}\n\n\t//\n\t// event logic\n\t//\n\n\tvar event_root = LinkedList.create();\n\n\tfunction eventCompare(p1_isStart, p1_1, p1_2, p2_isStart, p2_1, p2_2){\n\t\t// compare the selected points first\n\t\tvar comp = eps.pointsCompare(p1_1, p2_1);\n\t\tif (comp !== 0)\n\t\t\treturn comp;\n\t\t// the selected points are the same\n\n\t\tif (eps.pointsSame(p1_2, p2_2)) // if the non-selected points are the same too...\n\t\t\treturn 0; // then the segments are equal\n\n\t\tif (p1_isStart !== p2_isStart) // if one is a start and the other isn't...\n\t\t\treturn p1_isStart ? 1 : -1; // favor the one that isn't the start\n\n\t\t// otherwise, we'll have to calculate which one is below the other manually\n\t\treturn eps.pointAboveOrOnLine(p1_2,\n\t\t\tp2_isStart ? p2_1 : p2_2, // order matters\n\t\t\tp2_isStart ? p2_2 : p2_1\n\t\t) ? 1 : -1;\n\t}\n\n\tfunction eventAdd(ev, other_pt){\n\t\tevent_root.insertBefore(ev, function(here){\n\t\t\t// should ev be inserted before here?\n\t\t\tvar comp = eventCompare(\n\t\t\t\tev  .isStart, ev  .pt,      other_pt,\n\t\t\t\there.isStart, here.pt, here.other.pt\n\t\t\t);\n\t\t\treturn comp < 0;\n\t\t});\n\t}\n\n\tfunction eventAddSegmentStart(seg, primary){\n\t\tvar ev_start = LinkedList.node({\n\t\t\tisStart: true,\n\t\t\tpt: seg.start,\n\t\t\tseg: seg,\n\t\t\tprimary: primary,\n\t\t\tother: null,\n\t\t\tstatus: null\n\t\t});\n\t\teventAdd(ev_start, seg.end);\n\t\treturn ev_start;\n\t}\n\n\tfunction eventAddSegmentEnd(ev_start, seg, primary){\n\t\tvar ev_end = LinkedList.node({\n\t\t\tisStart: false,\n\t\t\tpt: seg.end,\n\t\t\tseg: seg,\n\t\t\tprimary: primary,\n\t\t\tother: ev_start,\n\t\t\tstatus: null\n\t\t});\n\t\tev_start.other = ev_end;\n\t\teventAdd(ev_end, ev_start.pt);\n\t}\n\n\tfunction eventAddSegment(seg, primary){\n\t\tvar ev_start = eventAddSegmentStart(seg, primary);\n\t\teventAddSegmentEnd(ev_start, seg, primary);\n\t\treturn ev_start;\n\t}\n\n\tfunction eventUpdateEnd(ev, end){\n\t\t// slides an end backwards\n\t\t//   (start)------------(end)    to:\n\t\t//   (start)---(end)\n\n\t\tif (buildLog)\n\t\t\tbuildLog.segmentChop(ev.seg, end);\n\n\t\tev.other.remove();\n\t\tev.seg.end = end;\n\t\tev.other.pt = end;\n\t\teventAdd(ev.other, ev.pt);\n\t}\n\n\tfunction eventDivide(ev, pt){\n\t\tvar ns = segmentCopy(pt, ev.seg.end, ev.seg);\n\t\teventUpdateEnd(ev, pt);\n\t\treturn eventAddSegment(ns, ev.primary);\n\t}\n\n\tfunction calculate(primaryPolyInverted, secondaryPolyInverted){\n\t\t// if selfIntersection is true then there is no secondary polygon, so that isn't used\n\n\t\t//\n\t\t// status logic\n\t\t//\n\n\t\tvar status_root = LinkedList.create();\n\n\t\tfunction statusCompare(ev1, ev2){\n\t\t\tvar a1 = ev1.seg.start;\n\t\t\tvar a2 = ev1.seg.end;\n\t\t\tvar b1 = ev2.seg.start;\n\t\t\tvar b2 = ev2.seg.end;\n\n\t\t\tif (eps.pointsCollinear(a1, b1, b2)){\n\t\t\t\tif (eps.pointsCollinear(a2, b1, b2))\n\t\t\t\t\treturn 1;//eventCompare(true, a1, a2, true, b1, b2);\n\t\t\t\treturn eps.pointAboveOrOnLine(a2, b1, b2) ? 1 : -1;\n\t\t\t}\n\t\t\treturn eps.pointAboveOrOnLine(a1, b1, b2) ? 1 : -1;\n\t\t}\n\n\t\tfunction statusFindSurrounding(ev){\n\t\t\treturn status_root.findTransition(function(here){\n\t\t\t\tvar comp = statusCompare(ev, here.ev);\n\t\t\t\treturn comp > 0;\n\t\t\t});\n\t\t}\n\n\t\tfunction checkIntersection(ev1, ev2){\n\t\t\t// returns the segment equal to ev1, or false if nothing equal\n\n\t\t\tvar seg1 = ev1.seg;\n\t\t\tvar seg2 = ev2.seg;\n\t\t\tvar a1 = seg1.start;\n\t\t\tvar a2 = seg1.end;\n\t\t\tvar b1 = seg2.start;\n\t\t\tvar b2 = seg2.end;\n\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.checkIntersection(seg1, seg2);\n\n\t\t\tvar i = eps.linesIntersect(a1, a2, b1, b2);\n\n\t\t\tif (i === false){\n\t\t\t\t// segments are parallel or coincident\n\n\t\t\t\t// if points aren't collinear, then the segments are parallel, so no intersections\n\t\t\t\tif (!eps.pointsCollinear(a1, a2, b1))\n\t\t\t\t\treturn false;\n\t\t\t\t// otherwise, segments are on top of each other somehow (aka coincident)\n\n\t\t\t\tif (eps.pointsSame(a1, b2) || eps.pointsSame(a2, b1))\n\t\t\t\t\treturn false; // segments touch at endpoints... no intersection\n\n\t\t\t\tvar a1_equ_b1 = eps.pointsSame(a1, b1);\n\t\t\t\tvar a2_equ_b2 = eps.pointsSame(a2, b2);\n\n\t\t\t\tif (a1_equ_b1 && a2_equ_b2)\n\t\t\t\t\treturn ev2; // segments are exactly equal\n\n\t\t\t\tvar a1_between = !a1_equ_b1 && eps.pointBetween(a1, b1, b2);\n\t\t\t\tvar a2_between = !a2_equ_b2 && eps.pointBetween(a2, b1, b2);\n\n\t\t\t\t// handy for debugging:\n\t\t\t\t// buildLog.log({\n\t\t\t\t//\ta1_equ_b1: a1_equ_b1,\n\t\t\t\t//\ta2_equ_b2: a2_equ_b2,\n\t\t\t\t//\ta1_between: a1_between,\n\t\t\t\t//\ta2_between: a2_between\n\t\t\t\t// });\n\n\t\t\t\tif (a1_equ_b1){\n\t\t\t\t\tif (a2_between){\n\t\t\t\t\t\t//  (a1)---(a2)\n\t\t\t\t\t\t//  (b1)----------(b2)\n\t\t\t\t\t\teventDivide(ev2, a2);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t//  (a1)----------(a2)\n\t\t\t\t\t\t//  (b1)---(b2)\n\t\t\t\t\t\teventDivide(ev1, b2);\n\t\t\t\t\t}\n\t\t\t\t\treturn ev2;\n\t\t\t\t}\n\t\t\t\telse if (a1_between){\n\t\t\t\t\tif (!a2_equ_b2){\n\t\t\t\t\t\t// make a2 equal to b2\n\t\t\t\t\t\tif (a2_between){\n\t\t\t\t\t\t\t//         (a1)---(a2)\n\t\t\t\t\t\t\t//  (b1)-----------------(b2)\n\t\t\t\t\t\t\teventDivide(ev2, a2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t//         (a1)----------(a2)\n\t\t\t\t\t\t\t//  (b1)----------(b2)\n\t\t\t\t\t\t\teventDivide(ev1, b2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//         (a1)---(a2)\n\t\t\t\t\t//  (b1)----------(b2)\n\t\t\t\t\teventDivide(ev2, a1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// otherwise, lines intersect at i.pt, which may or may not be between the endpoints\n\n\t\t\t\t// is A divided between its endpoints? (exclusive)\n\t\t\t\tif (i.alongA === 0){\n\t\t\t\t\tif (i.alongB === -1) // yes, at exactly b1\n\t\t\t\t\t\teventDivide(ev1, b1);\n\t\t\t\t\telse if (i.alongB === 0) // yes, somewhere between B's endpoints\n\t\t\t\t\t\teventDivide(ev1, i.pt);\n\t\t\t\t\telse if (i.alongB === 1) // yes, at exactly b2\n\t\t\t\t\t\teventDivide(ev1, b2);\n\t\t\t\t}\n\n\t\t\t\t// is B divided between its endpoints? (exclusive)\n\t\t\t\tif (i.alongB === 0){\n\t\t\t\t\tif (i.alongA === -1) // yes, at exactly a1\n\t\t\t\t\t\teventDivide(ev2, a1);\n\t\t\t\t\telse if (i.alongA === 0) // yes, somewhere between A's endpoints (exclusive)\n\t\t\t\t\t\teventDivide(ev2, i.pt);\n\t\t\t\t\telse if (i.alongA === 1) // yes, at exactly a2\n\t\t\t\t\t\teventDivide(ev2, a2);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t//\n\t\t// main event loop\n\t\t//\n\t\tvar segments = [];\n\t\twhile (!event_root.isEmpty()){\n\t\t\tvar ev = event_root.getHead();\n\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.vert(ev.pt[0]);\n\n\t\t\tif (ev.isStart){\n\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.segmentNew(ev.seg, ev.primary);\n\n\t\t\t\tvar surrounding = statusFindSurrounding(ev);\n\t\t\t\tvar above = surrounding.before ? surrounding.before.ev : null;\n\t\t\t\tvar below = surrounding.after ? surrounding.after.ev : null;\n\n\t\t\t\tif (buildLog){\n\t\t\t\t\tbuildLog.tempStatus(\n\t\t\t\t\t\tev.seg,\n\t\t\t\t\t\tabove ? above.seg : false,\n\t\t\t\t\t\tbelow ? below.seg : false\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tfunction checkBothIntersections(){\n\t\t\t\t\tif (above){\n\t\t\t\t\t\tvar eve = checkIntersection(ev, above);\n\t\t\t\t\t\tif (eve)\n\t\t\t\t\t\t\treturn eve;\n\t\t\t\t\t}\n\t\t\t\t\tif (below)\n\t\t\t\t\t\treturn checkIntersection(ev, below);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tvar eve = checkBothIntersections();\n\t\t\t\tif (eve){\n\t\t\t\t\t// ev and eve are equal\n\t\t\t\t\t// we'll keep eve and throw away ev\n\n\t\t\t\t\t// merge ev.seg's fill information into eve.seg\n\n\t\t\t\t\tif (selfIntersection){\n\t\t\t\t\t\tvar toggle; // are we a toggling edge?\n\t\t\t\t\t\tif (ev.seg.myFill.below === null)\n\t\t\t\t\t\t\ttoggle = true;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttoggle = ev.seg.myFill.above !== ev.seg.myFill.below;\n\n\t\t\t\t\t\t// merge two segments that belong to the same polygon\n\t\t\t\t\t\t// think of this as sandwiching two segments together, where `eve.seg` is\n\t\t\t\t\t\t// the bottom -- this will cause the above fill flag to toggle\n\t\t\t\t\t\tif (toggle)\n\t\t\t\t\t\t\teve.seg.myFill.above = !eve.seg.myFill.above;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// merge two segments that belong to different polygons\n\t\t\t\t\t\t// each segment has distinct knowledge, so no special logic is needed\n\t\t\t\t\t\t// note that this can only happen once per segment in this phase, because we\n\t\t\t\t\t\t// are guaranteed that all self-intersections are gone\n\t\t\t\t\t\teve.seg.otherFill = ev.seg.myFill;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\tbuildLog.segmentUpdate(eve.seg);\n\n\t\t\t\t\tev.other.remove();\n\t\t\t\t\tev.remove();\n\t\t\t\t}\n\n\t\t\t\tif (event_root.getHead() !== ev){\n\t\t\t\t\t// something was inserted before us in the event queue, so loop back around and\n\t\t\t\t\t// process it before continuing\n\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\tbuildLog.rewind(ev.seg);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// calculate fill flags\n\t\t\t\t//\n\t\t\t\tif (selfIntersection){\n\t\t\t\t\tvar toggle; // are we a toggling edge?\n\t\t\t\t\tif (ev.seg.myFill.below === null) // if we are a new segment...\n\t\t\t\t\t\ttoggle = true; // then we toggle\n\t\t\t\t\telse // we are a segment that has previous knowledge from a division\n\t\t\t\t\t\ttoggle = ev.seg.myFill.above !== ev.seg.myFill.below; // calculate toggle\n\n\t\t\t\t\t// next, calculate whether we are filled below us\n\t\t\t\t\tif (!below){ // if nothing is below us...\n\t\t\t\t\t\t// we are filled below us if the polygon is inverted\n\t\t\t\t\t\tev.seg.myFill.below = primaryPolyInverted;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// otherwise, we know the answer -- it's the same if whatever is below\n\t\t\t\t\t\t// us is filled above it\n\t\t\t\t\t\tev.seg.myFill.below = below.seg.myFill.above;\n\t\t\t\t\t}\n\n\t\t\t\t\t// since now we know if we're filled below us, we can calculate whether\n\t\t\t\t\t// we're filled above us by applying toggle to whatever is below us\n\t\t\t\t\tif (toggle)\n\t\t\t\t\t\tev.seg.myFill.above = !ev.seg.myFill.below;\n\t\t\t\t\telse\n\t\t\t\t\t\tev.seg.myFill.above = ev.seg.myFill.below;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// now we fill in any missing transition information, since we are all-knowing\n\t\t\t\t\t// at this point\n\n\t\t\t\t\tif (ev.seg.otherFill === null){\n\t\t\t\t\t\t// if we don't have other information, then we need to figure out if we're\n\t\t\t\t\t\t// inside the other polygon\n\t\t\t\t\t\tvar inside;\n\t\t\t\t\t\tif (!below){\n\t\t\t\t\t\t\t// if nothing is below us, then we're inside if the other polygon is\n\t\t\t\t\t\t\t// inverted\n\t\t\t\t\t\t\tinside =\n\t\t\t\t\t\t\t\tev.primary ? secondaryPolyInverted : primaryPolyInverted;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{ // otherwise, something is below us\n\t\t\t\t\t\t\t// so copy the below segment's other polygon's above\n\t\t\t\t\t\t\tif (ev.primary === below.primary)\n\t\t\t\t\t\t\t\tinside = below.seg.otherFill.above;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tinside = below.seg.myFill.above;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tev.seg.otherFill = {\n\t\t\t\t\t\t\tabove: inside,\n\t\t\t\t\t\t\tbelow: inside\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (buildLog){\n\t\t\t\t\tbuildLog.status(\n\t\t\t\t\t\tev.seg,\n\t\t\t\t\t\tabove ? above.seg : false,\n\t\t\t\t\t\tbelow ? below.seg : false\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// insert the status and remember it for later removal\n\t\t\t\tev.other.status = surrounding.insert(LinkedList.node({ ev: ev }));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvar st = ev.status;\n\n\t\t\t\tif (st === null){\n\t\t\t\t\tthrow new Error('PolyBool: Zero-length segment detected; your epsilon is ' +\n\t\t\t\t\t\t'probably too small or too large');\n\t\t\t\t}\n\n\t\t\t\t// removing the status will create two new adjacent edges, so we'll need to check\n\t\t\t\t// for those\n\t\t\t\tif (status_root.exists(st.prev) && status_root.exists(st.next))\n\t\t\t\t\tcheckIntersection(st.prev.ev, st.next.ev);\n\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.statusRemove(st.ev.seg);\n\n\t\t\t\t// remove the status\n\t\t\t\tst.remove();\n\n\t\t\t\t// if we've reached this point, we've calculated everything there is to know, so\n\t\t\t\t// save the segment for reporting\n\t\t\t\tif (!ev.primary){\n\t\t\t\t\t// make sure `seg.myFill` actually points to the primary polygon though\n\t\t\t\t\tvar s = ev.seg.myFill;\n\t\t\t\t\tev.seg.myFill = ev.seg.otherFill;\n\t\t\t\t\tev.seg.otherFill = s;\n\t\t\t\t}\n\t\t\t\tsegments.push(ev.seg);\n\t\t\t}\n\n\t\t\t// remove the event and continue\n\t\t\tevent_root.getHead().remove();\n\t\t}\n\n\t\tif (buildLog)\n\t\t\tbuildLog.done();\n\n\t\treturn segments;\n\t}\n\n\t// return the appropriate API depending on what we're doing\n\tif (!selfIntersection){\n\t\t// performing combination of polygons, so only deal with already-processed segments\n\t\treturn {\n\t\t\tcalculate: function(segments1, inverted1, segments2, inverted2){\n\t\t\t\t// segmentsX come from the self-intersection API, or this API\n\t\t\t\t// invertedX is whether we treat that list of segments as an inverted polygon or not\n\t\t\t\t// returns segments that can be used for further operations\n\t\t\t\tsegments1.forEach(function(seg){\n\t\t\t\t\teventAddSegment(segmentCopy(seg.start, seg.end, seg), true);\n\t\t\t\t});\n\t\t\t\tsegments2.forEach(function(seg){\n\t\t\t\t\teventAddSegment(segmentCopy(seg.start, seg.end, seg), false);\n\t\t\t\t});\n\t\t\t\treturn calculate(inverted1, inverted2);\n\t\t\t}\n\t\t};\n\t}\n\n\t// otherwise, performing self-intersection, so deal with regions\n\treturn {\n\t\taddRegion: function(region){\n\t\t\t// regions are a list of points:\n\t\t\t//  [ [0, 0], [100, 0], [50, 100] ]\n\t\t\t// you can add multiple regions before running calculate\n\t\t\tvar pt1;\n\t\t\tvar pt2 = region[region.length - 1];\n\t\t\tfor (var i = 0; i < region.length; i++){\n\t\t\t\tpt1 = pt2;\n\t\t\t\tpt2 = region[i];\n\n\t\t\t\tvar forward = eps.pointsCompare(pt1, pt2);\n\t\t\t\tif (forward === 0) // points are equal, so we have a zero-length segment\n\t\t\t\t\tcontinue; // just skip it\n\n\t\t\t\teventAddSegment(\n\t\t\t\t\tsegmentNew(\n\t\t\t\t\t\tforward < 0 ? pt1 : pt2,\n\t\t\t\t\t\tforward < 0 ? pt2 : pt1\n\t\t\t\t\t),\n\t\t\t\t\ttrue\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\t\tcalculate: function(inverted){\n\t\t\t// is the polygon inverted?\n\t\t\t// returns segments\n\t\t\treturn calculate(inverted, false);\n\t\t}\n\t};\n}\n\nmodule.exports = Intersecter;\n","// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// simple linked list implementation that allows you to traverse down nodes and save positions\n//\n\nvar LinkedList = {\n\tcreate: function(){\n\t\tvar my = {\n\t\t\troot: { root: true, next: null },\n\t\t\texists: function(node){\n\t\t\t\tif (node === null || node === my.root)\n\t\t\t\t\treturn false;\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\tisEmpty: function(){\n\t\t\t\treturn my.root.next === null;\n\t\t\t},\n\t\t\tgetHead: function(){\n\t\t\t\treturn my.root.next;\n\t\t\t},\n\t\t\tinsertBefore: function(node, check){\n\t\t\t\tvar last = my.root;\n\t\t\t\tvar here = my.root.next;\n\t\t\t\twhile (here !== null){\n\t\t\t\t\tif (check(here)){\n\t\t\t\t\t\tnode.prev = here.prev;\n\t\t\t\t\t\tnode.next = here;\n\t\t\t\t\t\there.prev.next = node;\n\t\t\t\t\t\there.prev = node;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tlast = here;\n\t\t\t\t\there = here.next;\n\t\t\t\t}\n\t\t\t\tlast.next = node;\n\t\t\t\tnode.prev = last;\n\t\t\t\tnode.next = null;\n\t\t\t},\n\t\t\tfindTransition: function(check){\n\t\t\t\tvar prev = my.root;\n\t\t\t\tvar here = my.root.next;\n\t\t\t\twhile (here !== null){\n\t\t\t\t\tif (check(here))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tprev = here;\n\t\t\t\t\there = here.next;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tbefore: prev === my.root ? null : prev,\n\t\t\t\t\tafter: here,\n\t\t\t\t\tinsert: function(node){\n\t\t\t\t\t\tnode.prev = prev;\n\t\t\t\t\t\tnode.next = here;\n\t\t\t\t\t\tprev.next = node;\n\t\t\t\t\t\tif (here !== null)\n\t\t\t\t\t\t\there.prev = node;\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t\treturn my;\n\t},\n\tnode: function(data){\n\t\tdata.prev = null;\n\t\tdata.next = null;\n\t\tdata.remove = function(){\n\t\t\tdata.prev.next = data.next;\n\t\t\tif (data.next)\n\t\t\t\tdata.next.prev = data.prev;\n\t\t\tdata.prev = null;\n\t\t\tdata.next = null;\n\t\t};\n\t\treturn data;\n\t}\n};\n\nmodule.exports = LinkedList;\n","// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// converts a list of segments into a list of regions, while also removing unnecessary verticies\n//\n\nfunction SegmentChainer(segments, eps, buildLog){\n\tvar chains = [];\n\tvar regions = [];\n\n\tsegments.forEach(function(seg){\n\t\tvar pt1 = seg.start;\n\t\tvar pt2 = seg.end;\n\t\tif (eps.pointsSame(pt1, pt2)){\n\t\t\tconsole.warn('PolyBool: Warning: Zero-length segment detected; your epsilon is ' +\n\t\t\t\t'probably too small or too large');\n\t\t\treturn;\n\t\t}\n\n\t\tif (buildLog)\n\t\t\tbuildLog.chainStart(seg);\n\n\t\t// search for two chains that this segment matches\n\t\tvar first_match = {\n\t\t\tindex: 0,\n\t\t\tmatches_head: false,\n\t\t\tmatches_pt1: false\n\t\t};\n\t\tvar second_match = {\n\t\t\tindex: 0,\n\t\t\tmatches_head: false,\n\t\t\tmatches_pt1: false\n\t\t};\n\t\tvar next_match = first_match;\n\t\tfunction setMatch(index, matches_head, matches_pt1){\n\t\t\t// return true if we've matched twice\n\t\t\tnext_match.index = index;\n\t\t\tnext_match.matches_head = matches_head;\n\t\t\tnext_match.matches_pt1 = matches_pt1;\n\t\t\tif (next_match === first_match){\n\t\t\t\tnext_match = second_match;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tnext_match = null;\n\t\t\treturn true; // we've matched twice, we're done here\n\t\t}\n\t\tfor (var i = 0; i < chains.length; i++){\n\t\t\tvar chain = chains[i];\n\t\t\tvar head  = chain[0];\n\t\t\tvar head2 = chain[1];\n\t\t\tvar tail  = chain[chain.length - 1];\n\t\t\tvar tail2 = chain[chain.length - 2];\n\t\t\tif (eps.pointsSame(head, pt1)){\n\t\t\t\tif (setMatch(i, true, true))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (eps.pointsSame(head, pt2)){\n\t\t\t\tif (setMatch(i, true, false))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (eps.pointsSame(tail, pt1)){\n\t\t\t\tif (setMatch(i, false, true))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (eps.pointsSame(tail, pt2)){\n\t\t\t\tif (setMatch(i, false, false))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (next_match === first_match){\n\t\t\t// we didn't match anything, so create a new chain\n\t\t\tchains.push([ pt1, pt2 ]);\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.chainNew(pt1, pt2);\n\t\t\treturn;\n\t\t}\n\n\t\tif (next_match === second_match){\n\t\t\t// we matched a single chain\n\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.chainMatch(first_match.index);\n\n\t\t\t// add the other point to the apporpriate end, and check to see if we've closed the\n\t\t\t// chain into a loop\n\n\t\t\tvar index = first_match.index;\n\t\t\tvar pt = first_match.matches_pt1 ? pt2 : pt1; // if we matched pt1, then we add pt2, etc\n\t\t\tvar addToHead = first_match.matches_head; // if we matched at head, then add to the head\n\n\t\t\tvar chain = chains[index];\n\t\t\tvar grow  = addToHead ? chain[0] : chain[chain.length - 1];\n\t\t\tvar grow2 = addToHead ? chain[1] : chain[chain.length - 2];\n\t\t\tvar oppo  = addToHead ? chain[chain.length - 1] : chain[0];\n\t\t\tvar oppo2 = addToHead ? chain[chain.length - 2] : chain[1];\n\n\t\t\tif (eps.pointsCollinear(grow2, grow, pt)){\n\t\t\t\t// grow isn't needed because it's directly between grow2 and pt:\n\t\t\t\t// grow2 ---grow---> pt\n\t\t\t\tif (addToHead){\n\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\tbuildLog.chainRemoveHead(first_match.index, pt);\n\t\t\t\t\tchain.shift();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\tbuildLog.chainRemoveTail(first_match.index, pt);\n\t\t\t\t\tchain.pop();\n\t\t\t\t}\n\t\t\t\tgrow = grow2; // old grow is gone... new grow is what grow2 was\n\t\t\t}\n\n\t\t\tif (eps.pointsSame(oppo, pt)){\n\t\t\t\t// we're closing the loop, so remove chain from chains\n\t\t\t\tchains.splice(index, 1);\n\n\t\t\t\tif (eps.pointsCollinear(oppo2, oppo, grow)){\n\t\t\t\t\t// oppo isn't needed because it's directly between oppo2 and grow:\n\t\t\t\t\t// oppo2 ---oppo--->grow\n\t\t\t\t\tif (addToHead){\n\t\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\t\tbuildLog.chainRemoveTail(first_match.index, grow);\n\t\t\t\t\t\tchain.pop();\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\t\tbuildLog.chainRemoveHead(first_match.index, grow);\n\t\t\t\t\t\tchain.shift();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.chainClose(first_match.index);\n\n\t\t\t\t// we have a closed chain!\n\t\t\t\tregions.push(chain);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// not closing a loop, so just add it to the apporpriate side\n\t\t\tif (addToHead){\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.chainAddHead(first_match.index, pt);\n\t\t\t\tchain.unshift(pt);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.chainAddTail(first_match.index, pt);\n\t\t\t\tchain.push(pt);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// otherwise, we matched two chains, so we need to combine those chains together\n\n\t\tfunction reverseChain(index){\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.chainReverse(index);\n\t\t\tchains[index].reverse(); // gee, that's easy\n\t\t}\n\n\t\tfunction appendChain(index1, index2){\n\t\t\t// index1 gets index2 appended to it, and index2 is removed\n\t\t\tvar chain1 = chains[index1];\n\t\t\tvar chain2 = chains[index2];\n\t\t\tvar tail  = chain1[chain1.length - 1];\n\t\t\tvar tail2 = chain1[chain1.length - 2];\n\t\t\tvar head  = chain2[0];\n\t\t\tvar head2 = chain2[1];\n\n\t\t\tif (eps.pointsCollinear(tail2, tail, head)){\n\t\t\t\t// tail isn't needed because it's directly between tail2 and head\n\t\t\t\t// tail2 ---tail---> head\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.chainRemoveTail(index1, tail);\n\t\t\t\tchain1.pop();\n\t\t\t\ttail = tail2; // old tail is gone... new tail is what tail2 was\n\t\t\t}\n\n\t\t\tif (eps.pointsCollinear(tail, head, head2)){\n\t\t\t\t// head isn't needed because it's directly between tail and head2\n\t\t\t\t// tail ---head---> head2\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.chainRemoveHead(index2, head);\n\t\t\t\tchain2.shift();\n\t\t\t}\n\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.chainJoin(index1, index2);\n\t\t\tchains[index1] = chain1.concat(chain2);\n\t\t\tchains.splice(index2, 1);\n\t\t}\n\n\t\tvar F = first_match.index;\n\t\tvar S = second_match.index;\n\n\t\tif (buildLog)\n\t\t\tbuildLog.chainConnect(F, S);\n\n\t\tvar reverseF = chains[F].length < chains[S].length; // reverse the shorter chain, if needed\n\t\tif (first_match.matches_head){\n\t\t\tif (second_match.matches_head){\n\t\t\t\tif (reverseF){\n\t\t\t\t\t// <<<< F <<<< --- >>>> S >>>>\n\t\t\t\t\treverseChain(F);\n\t\t\t\t\t// >>>> F >>>> --- >>>> S >>>>\n\t\t\t\t\tappendChain(F, S);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// <<<< F <<<< --- >>>> S >>>>\n\t\t\t\t\treverseChain(S);\n\t\t\t\t\t// <<<< F <<<< --- <<<< S <<<<   logically same as:\n\t\t\t\t\t// >>>> S >>>> --- >>>> F >>>>\n\t\t\t\t\tappendChain(S, F);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// <<<< F <<<< --- <<<< S <<<<   logically same as:\n\t\t\t\t// >>>> S >>>> --- >>>> F >>>>\n\t\t\t\tappendChain(S, F);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif (second_match.matches_head){\n\t\t\t\t// >>>> F >>>> --- >>>> S >>>>\n\t\t\t\tappendChain(F, S);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (reverseF){\n\t\t\t\t\t// >>>> F >>>> --- <<<< S <<<<\n\t\t\t\t\treverseChain(F);\n\t\t\t\t\t// <<<< F <<<< --- <<<< S <<<<   logically same as:\n\t\t\t\t\t// >>>> S >>>> --- >>>> F >>>>\n\t\t\t\t\tappendChain(S, F);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// >>>> F >>>> --- <<<< S <<<<\n\t\t\t\t\treverseChain(S);\n\t\t\t\t\t// >>>> F >>>> --- >>>> S >>>>\n\t\t\t\t\tappendChain(F, S);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\treturn regions;\n}\n\nmodule.exports = SegmentChainer;\n","// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// filter a list of segments based on boolean operations\n//\n\nfunction select(segments, selection, buildLog){\n\tvar result = [];\n\tsegments.forEach(function(seg){\n\t\tvar index =\n\t\t\t(seg.myFill.above ? 8 : 0) +\n\t\t\t(seg.myFill.below ? 4 : 0) +\n\t\t\t((seg.otherFill && seg.otherFill.above) ? 2 : 0) +\n\t\t\t((seg.otherFill && seg.otherFill.below) ? 1 : 0);\n\t\tif (selection[index] !== 0){\n\t\t\t// copy the segment to the results, while also calculating the fill status\n\t\t\tresult.push({\n\t\t\t\tid: buildLog ? buildLog.segmentId() : -1,\n\t\t\t\tstart: seg.start,\n\t\t\t\tend: seg.end,\n\t\t\t\tmyFill: {\n\t\t\t\t\tabove: selection[index] === 1, // 1 if filled above\n\t\t\t\t\tbelow: selection[index] === 2  // 2 if filled below\n\t\t\t\t},\n\t\t\t\totherFill: null\n\t\t\t});\n\t\t}\n\t});\n\n\tif (buildLog)\n\t\tbuildLog.selected(result);\n\n\treturn result;\n}\n\nvar SegmentSelector = {\n\tunion: function(segments, buildLog){ // primary | secondary\n\t\t// above1 below1 above2 below2    Keep?               Value\n\t\t//    0      0      0      0   =>   no                  0\n\t\t//    0      0      0      1   =>   yes filled below    2\n\t\t//    0      0      1      0   =>   yes filled above    1\n\t\t//    0      0      1      1   =>   no                  0\n\t\t//    0      1      0      0   =>   yes filled below    2\n\t\t//    0      1      0      1   =>   yes filled below    2\n\t\t//    0      1      1      0   =>   no                  0\n\t\t//    0      1      1      1   =>   no                  0\n\t\t//    1      0      0      0   =>   yes filled above    1\n\t\t//    1      0      0      1   =>   no                  0\n\t\t//    1      0      1      0   =>   yes filled above    1\n\t\t//    1      0      1      1   =>   no                  0\n\t\t//    1      1      0      0   =>   no                  0\n\t\t//    1      1      0      1   =>   no                  0\n\t\t//    1      1      1      0   =>   no                  0\n\t\t//    1      1      1      1   =>   no                  0\n\t\treturn select(segments, [\n\t\t\t0, 2, 1, 0,\n\t\t\t2, 2, 0, 0,\n\t\t\t1, 0, 1, 0,\n\t\t\t0, 0, 0, 0\n\t\t], buildLog);\n\t},\n\tintersect: function(segments, buildLog){ // primary & secondary\n\t\t// above1 below1 above2 below2    Keep?               Value\n\t\t//    0      0      0      0   =>   no                  0\n\t\t//    0      0      0      1   =>   no                  0\n\t\t//    0      0      1      0   =>   no                  0\n\t\t//    0      0      1      1   =>   no                  0\n\t\t//    0      1      0      0   =>   no                  0\n\t\t//    0      1      0      1   =>   yes filled below    2\n\t\t//    0      1      1      0   =>   no                  0\n\t\t//    0      1      1      1   =>   yes filled below    2\n\t\t//    1      0      0      0   =>   no                  0\n\t\t//    1      0      0      1   =>   no                  0\n\t\t//    1      0      1      0   =>   yes filled above    1\n\t\t//    1      0      1      1   =>   yes filled above    1\n\t\t//    1      1      0      0   =>   no                  0\n\t\t//    1      1      0      1   =>   yes filled below    2\n\t\t//    1      1      1      0   =>   yes filled above    1\n\t\t//    1      1      1      1   =>   no                  0\n\t\treturn select(segments, [\n\t\t\t0, 0, 0, 0,\n\t\t\t0, 2, 0, 2,\n\t\t\t0, 0, 1, 1,\n\t\t\t0, 2, 1, 0\n\t\t], buildLog);\n\t},\n\tdifference: function(segments, buildLog){ // primary - secondary\n\t\t// above1 below1 above2 below2    Keep?               Value\n\t\t//    0      0      0      0   =>   no                  0\n\t\t//    0      0      0      1   =>   no                  0\n\t\t//    0      0      1      0   =>   no                  0\n\t\t//    0      0      1      1   =>   no                  0\n\t\t//    0      1      0      0   =>   yes filled below    2\n\t\t//    0      1      0      1   =>   no                  0\n\t\t//    0      1      1      0   =>   yes filled below    2\n\t\t//    0      1      1      1   =>   no                  0\n\t\t//    1      0      0      0   =>   yes filled above    1\n\t\t//    1      0      0      1   =>   yes filled above    1\n\t\t//    1      0      1      0   =>   no                  0\n\t\t//    1      0      1      1   =>   no                  0\n\t\t//    1      1      0      0   =>   no                  0\n\t\t//    1      1      0      1   =>   yes filled above    1\n\t\t//    1      1      1      0   =>   yes filled below    2\n\t\t//    1      1      1      1   =>   no                  0\n\t\treturn select(segments, [\n\t\t\t0, 0, 0, 0,\n\t\t\t2, 0, 2, 0,\n\t\t\t1, 1, 0, 0,\n\t\t\t0, 1, 2, 0\n\t\t], buildLog);\n\t},\n\tdifferenceRev: function(segments, buildLog){ // secondary - primary\n\t\t// above1 below1 above2 below2    Keep?               Value\n\t\t//    0      0      0      0   =>   no                  0\n\t\t//    0      0      0      1   =>   yes filled below    2\n\t\t//    0      0      1      0   =>   yes filled above    1\n\t\t//    0      0      1      1   =>   no                  0\n\t\t//    0      1      0      0   =>   no                  0\n\t\t//    0      1      0      1   =>   no                  0\n\t\t//    0      1      1      0   =>   yes filled above    1\n\t\t//    0      1      1      1   =>   yes filled above    1\n\t\t//    1      0      0      0   =>   no                  0\n\t\t//    1      0      0      1   =>   yes filled below    2\n\t\t//    1      0      1      0   =>   no                  0\n\t\t//    1      0      1      1   =>   yes filled below    2\n\t\t//    1      1      0      0   =>   no                  0\n\t\t//    1      1      0      1   =>   no                  0\n\t\t//    1      1      1      0   =>   no                  0\n\t\t//    1      1      1      1   =>   no                  0\n\t\treturn select(segments, [\n\t\t\t0, 2, 1, 0,\n\t\t\t0, 0, 1, 1,\n\t\t\t0, 2, 0, 2,\n\t\t\t0, 0, 0, 0\n\t\t], buildLog);\n\t},\n\txor: function(segments, buildLog){ // primary ^ secondary\n\t\t// above1 below1 above2 below2    Keep?               Value\n\t\t//    0      0      0      0   =>   no                  0\n\t\t//    0      0      0      1   =>   yes filled below    2\n\t\t//    0      0      1      0   =>   yes filled above    1\n\t\t//    0      0      1      1   =>   no                  0\n\t\t//    0      1      0      0   =>   yes filled below    2\n\t\t//    0      1      0      1   =>   no                  0\n\t\t//    0      1      1      0   =>   no                  0\n\t\t//    0      1      1      1   =>   yes filled above    1\n\t\t//    1      0      0      0   =>   yes filled above    1\n\t\t//    1      0      0      1   =>   no                  0\n\t\t//    1      0      1      0   =>   no                  0\n\t\t//    1      0      1      1   =>   yes filled below    2\n\t\t//    1      1      0      0   =>   no                  0\n\t\t//    1      1      0      1   =>   yes filled above    1\n\t\t//    1      1      1      0   =>   yes filled below    2\n\t\t//    1      1      1      1   =>   no                  0\n\t\treturn select(segments, [\n\t\t\t0, 2, 1, 0,\n\t\t\t2, 0, 0, 1,\n\t\t\t1, 0, 0, 2,\n\t\t\t0, 1, 2, 0\n\t\t], buildLog);\n\t}\n};\n\nmodule.exports = SegmentSelector;\n"],"names":["PolyBool","BuildLog","Epsilon","Intersecter","SegmentChainer","SegmentSelector","GeoJSON","buildLog","epsilon","operate","poly1","poly2","selector","seg1","segments","seg2","seg3","combine","polygon","bl","list","v","poly","i","regions","forEach","addRegion","calculate","inverted","segments1","segments2","combined","inverted1","inverted2","selectUnion","union","selectIntersect","intersect","selectDifference","difference","selectDifferenceRev","differenceRev","selectXor","xor","polygonFromGeoJSON","geojson","toPolygon","polygonToGeoJSON","fromPolygon","window","module","exports","my","nextSegmentId","curVert","push","type","data","JSON","parse","stringify","segmentId","checkIntersection","segmentChop","seg","end","pt","statusRemove","segmentUpdate","segmentNew","primary","segmentRemove","tempStatus","above","below","rewind","status","vert","x","log","txt","reset","selected","segs","chainStart","chainRemoveHead","index","chainRemoveTail","chainNew","pt1","pt2","chainMatch","chainClose","chainAddHead","chainAddTail","chainConnect","index1","index2","chainReverse","chainJoin","done","eps","pointAboveOrOnLine","left","right","Ax","Ay","Bx","By","Cx","pointBetween","p","d_py_ly","d_rx_lx","d_px_lx","d_ry_ly","dot","pointsSameX","p1","p2","Math","abs","pointsSameY","pointsSame","pointsCompare","pointsCollinear","pt3","dx1","dy1","dx2","dy2","linesIntersect","a0","a1","b0","b1","adx","ady","bdx","bdy","axb","dx","dy","A","B","ret","alongA","alongB","pointInsideRegion","region","y","last_x","length","last_y","inside","curr_x","curr_y","GeoPoly","coords","LineString","ls","reg","slice","out","coordinates","Error","regionInsideRegion","r1","r2","newNode","children","roots","addChild","root","child","node","splice","forceWinding","clockwise","winding","copy","reverse","geopolys","addExterior","getInterior","LinkedList","selfIntersection","segmentCopy","start","id","myFill","otherFill","event_root","create","eventAdd","ev","other_pt","insertBefore","here","p1_isStart","isStart","p1_1","p1_2","p2_isStart","p2_1","p2_2","other","comp","eventAddSegment","ev_start","eventAddSegmentStart","ev_end","eventAddSegmentEnd","eventDivide","ns","remove","eventUpdateEnd","primaryPolyInverted","secondaryPolyInverted","status_root","statusFindSurrounding","findTransition","ev1","ev2","a2","b2","a1_equ_b1","a2_equ_b2","a1_between","a2_between","isEmpty","getHead","surrounding","before","after","checkBothIntersections","eve","toggle","insert","st","exists","prev","next","s","forward","check","last","chains","console","warn","first_match","matches_head","matches_pt1","second_match","next_match","head","chain","tail","setMatch","addToHead","grow","grow2","oppo","oppo2","shift","pop","unshift","F","S","reverseF","reverseChain","appendChain","chain1","chain2","tail2","head2","concat","select","selection","result"],"sourceRoot":""}